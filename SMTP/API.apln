:namespace API
    _Version←'0.9.5' '2022-06-24'
    NL←⎕UCS 13
    ⎕ml←1
    ⎕io←1
    Timeout←180 ⍝ seconds before we consider a job to have timedout
    DEBUG←⎕se.SALTUtils.DEBUG   ⍝ only allow debugging if we're in UCMD-DEBUG mode (currently disabled anyway)
    ⍝ return code:                                             0              1              2              3                           4                   5            6                                7                              8                          9
    ResultSymbols←↑((⎕ucs 183)'success')('-' 'failure')('t' 'timeout')('n' 'no status file found (job not executed, see Jenkins-log)')('i' 'invalid file')('e' 'error')('c' 'APLCORE while running test')('w' 'WS FULL executing test')('¢' 'classic vs. unicode')('~' 'disabled')
    If←/⍨   ⍝  AB's father
    cJSON←{1 ⎕JSON ⎕OPT'Compact' 0⊣⍵}
    _CopyFolder_mode←0    ⍝ 0=normal, ¯1=collect

    ∇ (R log)←GetAPI arg
⍝:: Load CITAs API into ⎕SE.CITA.API
⍝?: ]GetAPI
⍝?: needs no arguments. It ensures that the CITA API is loaded into ⎕SE.CITA.API
⍝UParse:''
⍝A?: not available for API-calls!
      R←0 ⋄ log←''
⍝ no code neccessary! the "Init"-fn in Cita.dyalog (which is executed prior to calling any UCMDs takes care of implemting the functionality...)
    ∇



    ∇ (R log)←APLVersions arg;k;i;keys;int;exe;bak;cnt;file;json;old;doc;platform;fld;z1;z2;t;old∆;k2;lglv;hlp;args;res;updated
⍝:: Reports the current list of local interpreters (or updates it with the right modifieres set)
⍝?:
⍝?: ]APLVersions
⍝?: Without arguments, prints a list of local interpreters (according to interpreters.json5)
⍝?: * ]APLVersions -update:   rebuild list
⍝?: * ]APLVersions <filter>: use the "version filtering DSL" to enable or disable selected interpreters.
⍝?:                          as this has a "global effect", it should be used with care only tp disable interpreters
⍝?:                          that you are sure you don't want to use with CITA.
⍝?:  interpreters.json is located in different folders, depending on the OS. Running the command will show the location of the file.
⍝??: APLVersions: The <version filtering DSL>
⍝??: [mode][[version[s]]|/][edition][bits]
⍝??: [mode] is optional, default is + (select). Alternative values: ~ (=un-select, disable)
⍝??: [version] is any number, optionally with decimals and selects a version-number. Using syntax from-to you may also specify a range of versions
⍝??:           if version(s) is elided, a / must be given to indicate missing first element. (This allows us to recognize "/32" as a bitness-selector)
⍝??: [edition] ∊uUcC or _: Unicode, Class or "_" for both
⍝??: [bits]    is 32 or 64 or can be elided to select both
⍝??: each of the three elements can be elided, but at least one must be given for a sensible selection obviously...
⍝UParse: 1S -update
⍝AParse: 1S -update -ucmd=0 -loglevel∊0123 -compact= 1 2
⍝A?: This describes the syntax for calls through the API-Interface.
⍝A?: loglevel provides a possibility to select the desired level of detail for the messages in the log.
⍝A?: the level of detail increases as numbers increase in value:
⍝A?: 0 - no logging at all
⍝A?: 1 - simple msg about the name of the file that was created or updated
⍝A?: 2 - report new or disabled interpreters
⍝A?: 3 - everything
⍝A?:
⍝A?: Additionally, the API-Call can use the option "-compact" to select result:
⍝A?: -compact=1: generate two-row report of enabled & disabled APL-Interpreters
⍝A?: -compact=2: two-element vector with ids of enabled & disabled interpreters
     
⍝ the "standard"-header for the API-Functions takes care of providing help when the fn is called directly
      var←3
      _InitUCMDs
      ns←⎕NS''
      ns.(rc Log)←0 ''
      :If ''=⍥⎕DR arg                              ⍝ if arg is char,
          arg←arg{~∨/⍵⍷⎕C ⍺:⍺,' ',⍵ ⋄ ⍺}'-ucmd=0'  ⍝ this is an API-Call - so be sure to add the -ucmd=0-modifier if we don't see it
          hlp←∨/('-?'⍷⍕arg)                        ⍝ remember if user asked for help
          args←##._Parse arg
          :If hlp                                   ⍝ if he asked for help
              ns.(rc log)←args                              ⍝ return it (Parse will have put it into its result!)
              →0                                    ⍝ and exit
          :EndIf
      :Else
          args←arg
      :EndIf
     
      int←⍬
      R←0
      log←''
      :If ⎕NEXISTS file←_FileWithListOfInterpreters
          log←⊂'Using list of interpreters from file "',file,'"'
          old∆←⎕JSON ⎕JSON old←(⎕JSON ⎕OPT'Dialect' 'JSON5')1⊃⎕NGET file
          :If 0=0 args.Switch'update'
              res←FilterAPLVersions((args._1≢0)/args._1),' -get=V'
              :If updated←args._1≢0 ⍝ if DSL was given, process it
                  Disable←{⍝ ⍺=interpreters,  ⍵[1] ids to handle, ⍵[2]=new value
                      i←⍸⍺.id∊int←1⊃⍵
                      ⍺{16::NOP←⍬ ⋄ ⍺[i].disabled←⍵[2]}⍵  ⍝ avoid NONCE ERROR if i=⍳0
                      z←~int∊⍺.id
                      ∨/z:log,←⊂'Version(s) ',(¯2↓∊'"',¨int,¨⊂'", '),' not found!'
                  }
                  :If 0≢t←2⊃res
                      old Disable t(∊'"Disabled with ""]APLVersions -disable"" on "Dddd, DDoo Mmmm YYYY; hh:mm:ss'(1200⌶)1 ⎕DT⊂⎕TS)
                  :EndIf
                  :If 0≢t←1⊃res
                      old Disable t''
                  :EndIf
              :EndIf
              k←↑7↑¨({6::0 ⋄ 'doc'≢⍵.id:0=≢⍵.disabled ⋄ 0}¨old)/old.id
              k2←↑7↑¨({6::1 ⋄ 'doc'≢⍵.id:0<≢⍵.disabled ⋄ 0}¨old)/old.id
              :If 1=0 args.Switch'compact'
                  log,←⊂'enabled : ',¯2↓,(k,','),' '
                  log,←⊂'disabled: ',¯2↓,(k2,','),' '
              :ElseIf 2=0 args.Switch'compact'
                 ⍝ compact=2: return two vectors of vtvs with enabled/disabled interpreters
                  log←↓¨k k2
              :Else
                  log,←⊂'enabled   disabled'
                  log,←⊂'-------   --------'
                  log,←↓k{a←⍺,' ' ⋄ a,⍥{(a⌈⍥≢w)↑⍵}⍵}w←' ',' ',k2
              :EndIf
              :If 1=0 args.Switch'ucmd'
                  R←⍬     ⍝ indicator that we do not want indicator for status of R
              :EndIf
              :If updated
                  (⊂cJSON old)⎕NPUT file 1
                    ⍝log,←⊂'Updated file "',file,'"'
              :EndIf
              →End
          :EndIf
      :ElseIf 1≢0 args.Switch'update'
          log←⊂'No list of interpreters found. File ',file,' does not exist.'
          →End
      :EndIf
     
      lglv←2 args.Switch'loglevel'
     
      :Select platform
     
      :Case 'Win'
          keys←##.WinReg.GetAllSubKeyNames dyalog←'HKEY_CURRENT_USER\SOFTWARE\Dyalog'
          :For k :In keys
              :If (12↑k)≡'Dyalog APL/W'  ⍝ is it an interpreter
                  exe←(##.WinReg.GetString dyalog,'\',k,'\Dyalog'){⍺,((~∨/'\/'=¯1↑⍺)/'\'),⍵}'dyalog.exe'
                  :If ⎕NEXISTS exe
                      i←⎕NS'' ⍝ collect data in this ns
                      i.exe←∊1 ⎕NPARTS exe
                      i.Bits←(32 64)[1+'-64'≡3↑12↓k]
                      i.Edition←'CU'[1+∨/'Unicode'⍷k]
                      i.Version←3⊃2⊃' '⎕VFI k
                      i.id←i.((⍕Version×10),Edition,⍕Bits)
                      int,←i
                  :ElseIf lglv>1
                      log,←⊂'Registry key "',k,'" was not considered because "',exe,'" was not found!'
                  :EndIf
              :EndIf
          :EndFor
      :Case 'Mac'
          :For fld :In '/Applications/Dyalog*' '/Dyalog/Dyalog*'
              :For k :In ⊃0(⎕NINFO ⎕OPT 1)
                  exe←k,'/Contents/Resources/Dyalog/mapl'
                  :If ⎕NEXISTS exe
                      i←⎕NS'' ⍝ collect data in this ns
                      i.exe←∊1 ⎕NPARTS exe
                      i.Bits←64
                      i.Edition←'U'
                      i.Version←2⊃2⊃'-'⎕VFI ¯4↓k
                      i.id←i.((⍕Version×10),Edition,⍕Bits)
                      int,←i
                  :ElseIf lglv>1
                      log,←⊂'Folder "',k,'" was excluded because it did not contain expected "',exe,'"'
                  :EndIf
              :EndFor
          :EndFor
      :Case 'Lin'
          :For exe :In ⊃0(⎕NINFO ⎕OPT'Recurse' 1)'/opt/mdyalog/mapl'
              :If ⎕NEXISTS exe
                  i←⎕NS'' ⍝ collect data in this ns
                  i.exe←∊1 ⎕NPARTS exe
                  i.Bits←64
                  i.Edition←'CU'[1+∨/'unicode'⍷exe]
                  i.Version←4⊃2⊃'/'⎕VFI exe
                  i.id←i.((⍕Version×10),Edition,⍕Bits)
                  int,←i
              :ElseIf lglv>1
                  log,←⊂'Folder "',k,'" was excluded because it did not contain expected "',exe,'"'
              :EndIf
          :EndFor
     
      :EndSelect
     
     
     
      :If 0<≢int
          doc←⎕NS''
          doc.id←'doc'
          doc._←⊂'This file is created, used and updated by CITA (Continous Integration & Testing in APL)         '
          doc._,←⊂'------------------------------------------------------------------------------------------------'
          doc._,←⊂'It contains the complete inventory of locally installed interpreters that might be used in tests'
          doc._,←⊂'when ExecuteLocalTests is called with the ''a''-Flag.                                             '
          doc._,←⊂'It is possible to indicate non-availability for tests of individual interpreters by setting     '
          doc._,←⊂'''disabled'' to a non-empty string.                                                               '
          doc._,←⊂'The ''id''-field is used to identify interpreters, while ''Bits'' and ''Edition'' describe the        '
          doc._,←⊂'respective characteristics of an interpreter.                                                   '
          doc._,←⊂'If any interpreter in this list should not be found again on a re-scan, its entry will get      '
          doc._,←⊂'a value in the ''disabled''-field, we never delete from this list! Newly installed interpreters   '
          doc._,←⊂'will be added (and will be enabled) automatically.                                              '
          doc.disabled←'Doc is read, not executed!'
     
          int←doc,int
     
          :If ⎕NEXISTS file
              :If old.id≡(⊂'doc'),int.id
              :AndIf old≡⍥{6::'' ⋄ ⍵.disabled}int  ⍝ also compare "disabled" - but avoid VALUE ERRORs
              :AndIf old≡⍥{6::'' ⋄ ⍵.exe}int
                  R←1
                  :If lglv>0 ⋄ log←⊂'No changes found - file "',file,'" was not replaced' ⋄ :EndIf
                  →End
              :Else
                  z1←({6::1 ⋄ 0=≢⍵.disabled}¨old)∧~old.id∊int.id
                  :If ∨/z1
                      (z1/old)⍎¨⊂'disabled←∊''"Disabled by interpreter-scan on "Dddd, DDoo Mmmm YYYY; hh:mm:ss''(1200⌶)1 ⎕DT ⊂⎕TS'
                      :If lglv>1
                          log,←⊂'Disabled ',(¯2↓∊'"',¨z1/old.id,¨⊂'", '),' which were not found'
                      :EndIf
                  :EndIf
                  z2←~int.id∊old.id
                  old←old,z2/int
                  :If ∨/z2
                      (z2/int)⍎¨⊂'Added←∊''"Added on "Dddd, DDoo Mmmm YYYY; hh:mm:ss''(1200⌶)1 ⎕DT ⊂⎕TS'
                      :If lglv>1
                          log,←⊂'Found and included new interpreters: ',¯2↓∊'"',¨z2/int.id,¨⊂'", '
                      :EndIf
                  :EndIf
                  :If 1∊z1,z2
                      old←old[⍋old.id]
                      old←old[(≢old){⍵,(⍳⍺)~⍵}old.id⍳⊂'doc']  ⍝ make sure doc stays on top
                      (⊂cJSON old)⎕NPUT file 1
                      :If lglv>0
                          log,←⊂'Updated "',file,'"'
                      :EndIf
                  :Else
                      log←'No changes found, "',file,'" is still current.'
                  :EndIf
              :EndIf
          :Else
              :If lglv>0
                  log,←⊂'Created "',file,'"'
              :EndIf
              (⊂cJSON int)⎕NPUT file
          :EndIf
          R←1
      :Else
          R←0
          log,←⊂'Nothing to do - no interpreters found! (How did you even execute this code?)'
      :EndIf
     End:
      :If 1=0 args.Switch'ucmd'
          R←⍬  ⍝ no need to show interpretation of rc when running UCMD
      :EndIf
      ns.(rc Log)←R log
    ∇

    ∇ {ns}←ExecuteLocalTest arg;fld;fl;loc;xin;rc;specs;R;step;specsObj;lg;cnt;list;showedIO;log;del;list2;v;xin∆;jlog;cfg;rcTest;interpreters;interpreter;t;int;resTab;plus;V;B;b;E;xinO;lint;dot;item;legend;symb;summary;exp;Log;jobR;res;keep;resNS;goto
⍝:: Execute local tests
⍝?: Execute local tests
⍝?:
⍝?: ]ExecuteLocalTest <path>CITA.json[5] [-keep[∊RCcr]] -keeponfailure[∊RCcr] [-int[=180U64...]
⍝Parse:              1L                  -keep[∊]RCcr  -keeponfailure[∊]RCcr  -int[∊]"0123456789UCuc_/,.~-all" -workdir= -off -trace
⍝AParse:             1L                  -keep[∊]RCcr  -keeponfailure[∊]RCcr  -int[∊]"0123456789UCuc_/,.~-all" -workdir= -ucmd=0 -off -trace
⍝??: Execute local tests
⍝??:
⍝??: ]ExecuteLocalTest <path>CITA.json[5] [-keep[=C|R]] [-int=180U64...]
⍝??: <path>               location of CITA.json or CITA.json5 file OR http[s]-URL of a repo that has a CITA.json[5] file
⍝??: <folder>             tests are executed in an automatically created subfolder of TEMP/CITA_Test/yymmdd_hhmmss
⍝??:
⍝??: -int=ids             test against a subset of specified interpreters (comma-separated list of filters using the "version filtering DSL" of ]APLVersions)
⍝??:                      just use modifies w/o assigning value to run tests against all enabled interpreters
⍝??:
⍝??: -keep                which files should be keep after running the tests? (Default (if -keep is used w/o value) is "cr")
⍝??: -keep=c              code - the content of the folder/repository that was tested
⍝??: -keep=r              results - everything created while running tests (APLCOREs, log files of APL Session or DTest etc.)
⍝??:
⍝??: -keeponfailure       different keep-Settings i case tests fail. (Default (if -keeponfailure is given without values) is "cr"))
⍝??: -keeponfailure=cr    one or both of cr (casing is irrlevant) can be used with the same meaning as before with -keep
⍝??: -off                 exit when completed. will set pass returncode to O/S (0=ok, anything else: error)
⍝??:
⍝??: Hint: the result's header gives a first quick indication of the result: straight line indicates success. dashed line means failure!
⍝??: ]APLVersions -??   ⍝ for a description of the "version filtering DSL"
⍝A?: The additional modifier "-workdir=<path>" can be used to select the base path for the tests.
⍝A?: Result is a namespace with these elements:
⍝A?: rc - return code
⍝A?:      ¯1=no test executed
⍝A?:       0=ok
⍝A?:       1=Test failed (Details in the Log)
⍝A?: Individual tests have returncodes as well (they are shown in "Log"). These come with a higher granularity,
⍝A? i.e. there's a better differentiation of the problems that occured:
⍝A?:       0= all ok
⍝A?:       1=test failed
⍝A?:       2=aborted because of Timeout
⍝A?:       3=no status file found
⍝A?:       4=invalid or non-existent file
⍝A?:       5=APL errors executing test
⍝A?:       6=executing test ended with APLCORE
⍝A?:       7=WS FULL
⍝A?:       8=Likely hit a Classic vs. Unicode-error (TRANSLATION ERROR etc.)
⍝A?:       9=Test disabled
⍝A?:      10=Found Jenkins issues executing script
⍝A?: Log
⍝A?: testMat:  Matrix - Tests x Interpreters with single-letter result of corresponding test.
⍝A?:           First row/col has titles of tests and interpreters
      _InitUCMDs
      ns←⎕NS''
      res←¯1  ⍝ res=¯1 indicates no test were run!
      Log←''
      hlp←∨/('-?'⍷⍕arg)                        ⍝ remember if user asked for help
      arg←##._Parse arg
      :If hlp                                   ⍝ if he asked for help
          ns.(rc Log)←0 args                              ⍝ return it (Parse will have put it into its result!)
          →0                                    ⍝ and exit
      :EndIf
     
      :If arg.trace≡1 ⋄ (⍳≢⎕NR 1⊃⎕SI)⎕TRACE 1⊃⎕SI ⋄ :EndIf
      fl←1 ''##._getArg 1 arg  ⍝ fld=folder, fl=path to a CITA.json
      fl←_ExpandEnvVars fl
      fl←∊1 ⎕NPARTS fl
      ('File or directory "',fl,'" not found')⎕SIGNAL(~⎕NEXISTS fl)/700
      :If 1=1 ⎕NINFO fl
          fl←∊0(⎕NINFO ⎕OPT'Wildcard' 1)(fl,'/CITA.json*')
      :EndIf
     
      fld←1⊃⎕NPARTS fl
      :If ''≡xinO←_ExpandEnvVars''##._getArg'workdir'arg
          xinO←(739⌶0),,'</CITA_Test/>,ZI4,ZI2,ZI2,<_>,ZI2,ZI2,ZI2,</>'⎕FMT 1 6⍴⎕TS
          3 ⎕MKDIR xinO
      :EndIf
      :If ~⎕NEXISTS xinO
          ns.rc←¯1
          ns.Log←'Workdir "',xinO,'" not found!'
          →0
      :EndIf
     
      int←0  ⍝ count of interpreter
      interpreters←,0  ⍝ default (signals to APLProcess to use current)
      resTab←1 1⍴' '  ⍝ tests x Interpreters - a summary table of test-results  - first row/col contains ids/names
      showedIO←0   ⍝ when we display test-counts instead of ids, give info about IO=1 (this var ensures we're doing it once only!)
      rcTest←¯1  ⍝ ¯1: no tests executed
      :If (~(⎕NEXISTS ⎕OPT'Wildcard' 1)fl)∨'cita.json'≢9↑⎕C∊1↓⎕NPARTS fl
          ns.(rc Log)←700 'CITA.JSON[5] not found'
          →0
      :EndIf
     
      (rc specsObj lg)←_GetTestSpecs fl
     
      :If rc≠0
          ns.(rc Log)←701('Error processing specs in "',fl,'": ',⍕lg)
          →0
      :EndIf
      Log,←lg
      lint←''
      :If 0<≢lint←{1≡⍵:' ' ⋄ ⍵}''arg.Switch'int'
          lg←FilterAPLVersions{(∨\' '≠⍵)/⍵}lint,' -get=f'
          :If lint≢' '
              Log,←⊂'Filtered interpreters with "',lint,'"'
          :EndIf
          Log,←⊆'Testing against these active interpreters: ',¯2↓∊lg,¨⊂', '
          t←1⊃⎕NGET _FileWithListOfInterpreters
          interpreters←_FoldJson t
          interpreters←({6::1 ⋄ 'doc'≢⍵.id:0=≢⍵.disabled ⋄ 0}¨interpreters)/interpreters
          :If 0<≢lint
              interpreters←(interpreters.id∊lg)/interpreters
          :EndIf
      :EndIf
      Results←⎕NS''
      :For interpreter :In interpreters
          xin∆←xinO,{0::⍵ ⋄ interpreter.id,'_'}''
     
          :If interpreter≡0
              t←{(⍕+/10 1×2↑2⊃'.'⎕VFI 2⊃⍵),('CU'[1+80=⎕DR' ']),(1+'64'≡¯2↑1⊃⍵)⊃'32' '64'}'.'⎕WG'aplversion'
          :Else
              t←interpreter.id
              →NextInt If~⎕NEXISTS interpreter.exe ⍝ make sure interpreter does exist...
              :If 2=interpreter.⎕NC'disabled'
              :AndIf 0<≢interpreter.disabled
                  →NextInt
              :EndIf
          :EndIf
          int+←1
          resTab←resTab,⊂''
          resTab[1;1+int]←⊂t
          cnt←0
          :If interpreters≢,0
              Log,←⊂'Interpreter ',interpreter.id
          :EndIf
     
          :For specs :In specsObj  ⍝ loop through multiple tests
              cnt+←1
              :If (cnt+1)>≢resTab
                  resTab←resTab⍪⊂''
                  resTab[cnt+1;1]←⊂specs.id
              :EndIf
              :If 2=specs.⎕NC'disabled'
              :AndIf 0<≢specs.disabled
                  resTab[cnt+1;int+1]←'~'
                  :Continue
              :EndIf
            ⍝   :If int=1 ⋄ resTab←resTab⍪⊂'' ⋄ resTab[cnt+1;1]←⊂specs.id ⋄ :EndIf
           ⍝ test if this apl qualifies...
              resTab[cnt+1;int+1]←'~'  ⍝ we assume it doesn't - this will be overridden later if it does
              :If 2=specs.⎕NC'dyalogversions'
                  :If 0<≢v←specs.dyalogversions
                      :If interpreter≡0
                          V←+/1 0.1×2↑2⊃'.'⎕VFI 2⊃'.'⎕WG'aplversion'  ⍝ current version
                      :Else
                          V←interpreter.version
                      :EndIf
                      ⍝ V=test engine, v=specs
                      plus←0  ⍝ did we see a +sign?
                      :If (⎕DR' ')=⎕DR v  ⍝ , separated list or a single version, possibly with "+
                          v←','(≠⊆⊢)v
                          (v plus dot)←↓⍉↑{(p d)←'+.'∊⍵ ⋄ (⊃2⊃⎕VFI ⍵~'+'),p,d}¨v
                      :Else
                          (v plus dot)←↓⍉↑{' '≠⍥⎕DR ⍵:⍵,0 0 ⋄ (p d)←'+.'∊⍵ ⋄ (⊃2⊃⎕VFI ⍵~'+'),p,d}¨,v
                      :EndIf
                      :If ~∨/(V∊v),(plus∧v<V),((~dot)∧V∊⍥⌊v)
                          :If interpreter≡0
                              Log,←⊂'Current interpreter (v=',(⍕V),') rejected by test which selected "',(⍕specs.dyalogversions),'"'
                          :Else
                              Log←(¯1↓Log),⊂'Interpreter ',interpreter.id,'(v=',(⍕V),') rejected by test which selected "',(⍕specs.dyalogversions),'"'
                          :EndIf
                          →EndForSpec
                      :EndIf
                    ⍝   ⎕←'V=',V,', v=',v
                  :EndIf
              :EndIf
              :If 2=specs.⎕NC'bits'
                  :If interpreter≡0
                      B←{⍵:64 ⋄ 32}∨/'64'⍷1⊃'.'⎕WG'APLVersion'
                  :Else
                      B←interpreter.bits
                  :EndIf
                  :If ~B∊specs.bits
                      :If interpreter≡0
                          Log,←⊂'Current interpreter (bits=',(⍕B),') rejected by test which selected "',(⍕specs.bits),'"'
                      :Else
                          Log,←⊂'Interpreter ',interpreter.id,' rejected by test which selected "',(⍕specs.bits),'"'
                      :EndIf
                      →EndForSpec
                  :EndIf
              :EndIf
     
              :If 2=specs.⎕NC'edition'
                  :If interpreter=0
                      E←(1+80=⎕DR' ')⊃'CU'
                  :Else
                      E←interpreter.edition
                  :EndIf
                  :If ~E∊specs.edition
                      :If interpreter≡0
                          Log,←⊂'Current interpreter (edition==',(⍕E),') rejected by test which selected "',(⍕specs.edition),'"'
                      :Else
                          Log,←⊂'Interpreter ',interpreter.id,' rejected by test which selected "',(⍕specs.edition),'"'
                      :EndIf
                      →EndForSpec
                  :EndIf
              :EndIf
              resTab[cnt+1;int+1]←' '
     
              log←''
              jobR←0 ''
              xin←xin∆,(⍕specs.id),'/'
              :Trap DEBUG↓0
                  3 ⎕MKDIR xin
              :Else
                  xin←xin∆,(⍕cnt),'/'
                  log,←⊂'The jobid "',specs.id,'" caused an error when attempting to create a folder with that name.'
                  :Trap DEBUG↓0
                      ⎕MKDIR xin
                      log,←⊂'Solved that using counter (',(⍕cnt),') instead.'
                  :Else
                      log,←⊂'** Attempt to use counter (',(⍕cnt),') failed as well! Giving up.' ⋄ →EndStep
                  :EndTrap
              :EndTrap
            ⍝   ⎕←'xin=',xin
            ⍝   ⎕←'fld=',fld
            ⍝   ⎕←'---log=',log
              :If 0≠xin _CopyFolder fld
                  (res log)←703 'Problem copying files into workdir-folder'
                  →EndStep
              :EndIf
     
⍝ remember files we had before tests were executed...
              list←⊃0(⎕NINFO ⎕OPT('Recurse' 1)('Wildcard' 1))xin,'*'
     
              cfg←''
              :If 9=specs.⎕NC'config'
                  cfg←∊specs.config{⍵,'=',(⍕⍺⍎⍵),' '}¨specs.config.⎕NL ¯2
              :ElseIf 2=specs.⎕NC'config'
                  cfg←specs.config
              :EndIf
     
              :For step :In 'setup' 'test' 'teardown'
                  :If step≡'test'
                  :AndIf 0=specs.⎕NC step
                      R←4 'Missing entry for step "test"'
                  :Else
                      fl←specs⍎step
                      ⍝ ⎕← interpreter.id,' ',step
                      ⍝ (⎕lc[1]+1)⎕stop 1⊃⎕si
                      nsJob←step _RunJob cfg specs interpreter
                      (rc jlog)←nsJob.(R log)
                      :If (⊂step)∊'setup' 'test'
                          rcTest←rc
                      :EndIf
                      :If step≡'test'
                          nsTest←nsJob
                          :If 2=nsJob.⎕NC'outfile'
                          :AndIf ⎕NEXISTS(1⊃⎕NPARTS nsJob.outfile),'MemRep.dcf'
                              t←((1⊃⎕NPARTS nsJob.outfile),'MemRep.dcf')⎕FSTIE 0
                              nsTest.(ai2 ai3)←⎕FREAD t,2
                              nsTest.MemRep←⎕FREAD t,1
                              ⎕FUNTIE t
                          :EndIf
                      :EndIf
                      :Select rc
                      :CaseList 0,(((⊂step)∊'setup' 'teardown')/4),(((⊂step)∊'test' 'teardown')/1)
                          R←0 '' ⍝ we do nothing here, but may need to catch these cases...(and continue to the next step)
                      :Case 1    ⍝ ...whereas we will :Leave in all other cases...
                          jobR←rc(jlog{0<≢⍺:⍺ ⋄ ⍵}step,' (using "',fl,'") failed')
                          :Leave
                      :Case 2
                          jobR←rc(jlog{0<≢⍺:⍺ ⋄ ⍵}step,' (using "',fl,'")  did not end properly (Timeout Error)')
                          :Leave
                      :Case 3
                          jobR←rc(jlog{0<≢⍺:⍺ ⋄ ⍵}'No statusfile (CITA.',step,'.[ok|err]) found after ',step,' ended')
                          :Leave
                      :Case 4
                          jobR←rc(jlog{0<≢⍺:⍺ ⋄ ⍵}'Invalid or non-existent file "',fl,'" for step "',step,'"')
                          jlog←''  ⍝ don't need joblog - it has no additional info
                          :Leave
                      :Case 5
                          jobR←rc(jlog{0<≢⍺:⍺ ⋄ ⍵}'APL Error executing code from ',fl)
                          :Leave
                      :Case 6
                          jobR←rc(jlog{0<≢⍺:⍺ ⋄ ⍵}step,' (using "',fl,'") ended with APLCORE!')
                          :Leave
                      :Case 7
                          jobR←rc(jlog{0<≢⍺:⍺ ⋄ ⍵}step,' (using "',fl,'") ended with WS FULL!')
                          :Leave
                      :Case 8
                          jobR←rc(jlog{0<≢⍺:⍺ ⋄ ⍵}step,' (using "',fl,'") probably had issue with Classic/Unicode-compatibility')
                          :Leave
                      :EndSelect
     
                  :EndIf
                  jobR[1]←(jobR[1]{∧/0=⍺,1⊃⍵:0 ⋄ 1⊃⍵}R)
                  jobR[2]←⊂(2⊃jobR),2⊃R
                  :If step≡'test'
                  :AndIf 2=nsJob.⎕NC'logFile'
                  :AndIf ⎕NEXISTS nsJob.logFile
                      jobR[2]←⊂(2⊃jobR),'Statusfile: ',nsJob.logFile,':',1⊃⎕NGET nsJob.logFile
                  :EndIf
     
              :EndFor
     
     EndStep:
              res←~(res∊0 ¯1)∧rcTest=0
              log,←2⊃jobR
              ⎕←'log=',log
              Log,←⊂((ResultSymbols[1;1],'~*')[3⍴0 ¯1⍳rcTest]),' ',('#',(⍕cnt),' ',((~showedIO)/' (⎕IO=1) '),{0<≢⍵:'"',⍵,'"'}specs.id),({⍵=0:': success ···' ⋄ ⍵=¯1:': not executed ~~~' ⋄ ': FAILURE (return code = ',(⍕⍵),') ***'}rcTest)
              ⎕←'Log=',Log
              showedIO←showedIO∨~''≡⍥⎕DR specs.id
     
              :If 0<≢log,jlog
                  log←(⊆log),⊆jlog
                  :If 1=≢log
                      Log,←⊂'    Message: "',log,'"'
                  :Else
                      Log,←⊂'     Log:'
                      Log,←⊂∊{(z/'     '),⍵,((z←0<≢⍵)∧~∨/(⎕UCS 13 10)∊∊⍵)/⎕UCS 13}¨log
                  :EndIf
              :EndIf
              Log,←⊂''
     
            ⍝   :If DEBUG ⋄ ⎕←'resTab[',(cnt+1),';',(int+1),']←"',ResultSymbols[1+rcTest;1],'"' ⋄ :EndIf
              resTab[cnt+1;int+1]←ResultSymbols[1+rcTest;1]
              list2←⊃0(⎕NINFO ⎕OPT('Recurse' 1)('Wildcard' 1))xin,'*'   ⍝ remember files we had before tests were executed...
              del←0⍴⊂''
     
              keep←arg.Switch'keep'
              :If rcTest≠0   ⍝ if test failed
              :AndIf 0≢arg.Switch'keeponfailure'
                  keep←arg.Switch'keeponfailure'
              :EndIf
     
              :Select keep←{⍵[⍋⍵]}⎕C,keep
              :Case ,'r'
                  del←(list2∊list)/list2
              :CaseList ,¨'c' 0   ⍝ 0=DEFAULT, if keep specified
                  del←list
              :Case 'cr'(,1)      ⍝ 1=if "-keep" was used
                  del←⍬
              :Case ''            ⍝ -keep=  > delete everything, keep nothing!
                  del←list2
              :EndSelect
              :Trap DEBUG↓0
                  :For item :In (⌽del),⊂xin
                      :If ⎕NEXISTS item
                          :If 1=⊃1 ⎕NINFO item              ⍝ if the items is a folder
                          :AndIf 0<≢⊃0(⎕NINFO ⎕OPT 1)item,'/*'   ⍝ and there are still files in it
                              del←del~⊂item                  ⍝ do not attempt to delete it
                          :Else
                              ⎕NDELETE item
                          :EndIf
                      :EndIf
                  :EndFor
              :Else
                  Log,←⊂'Trapped error while clearing folder "',xin,'":',NL,⎕DMX.(OSError{⍵,2⌽(×≢⊃⍬⍴2⌽⍺)/'") ("',⊃⍬⍴2⌽⍺}Message{⍵,⍺,⍨': '/⍨×≢⍺}⊃⍬⍴DM,⊂'')
                  Log,←⊂'Full details:',NL,cJSON ⎕DMX
                  res←702
                  →EndForSpec
              :EndTrap
     EndForSpec:
              :If 0<≢nsJob.⎕NL ¯2   ⍝ if anything was tested...
                  ⍝(resNS←'t_',(2⊃⎕NPARTS ¯1↓xinO))Results.⎕NS''
                  (resNS←'t_',specs.id)Results.⎕NS''
                  resNS←Results⍎resNS
                  resNS.Log←2⊃jobR
                  resNS.rc←rcTest
                  resNS{(⊂⍺ ⍵){⍎'(1⊃⍺).',⍵,'←(2⊃⍺)⍎⍵'}¨⍵.⎕NL ¯2}nsTest
            ⍝      :If 'test'≡step
            ⍝      :AndIf 9=⎕NC'nsTest'
                ⍝   ⎕←⎕JSON nsTest
                  :If 2=nsTest.⎕NC'outfile'
                    ⍝   ⎕←(≢xinO)↓nsTest.outfile
                      resNS.outfile←nsTest.outfile
                  :EndIf
              :EndIf
          :EndFor
     NextInt:
      :EndFor
      :If interpreters≢,0    ⍝ if we run against multiple interpreters
      :AndIf rcTest≠¯1       ⍝ and tests were actually executed...
          Log,←↓⍕resTab
          Log,←_AddLegend resTab
      :EndIf
      :If 2=⎕NC'keep'
      :AndIf ∨/'r'∊keep
          Log,←⊂'Logs (including this log) can be found in ',xin∆,' and subfolders'
          (⊂Log)⎕NPUT xin∆,'CITA.log'
      :EndIf
      ns.Log←Log
      ns.rc←res
      ns.testMat←resTab
    ⍝   ⎕←'Results=',cJSON Results
      cmnt←NL,' /***************** Results *******************',NL,(,(⍕resTab),⊂NL),' ****************************/',NL
      (⊂cmnt{⍵[1],⍺,1↓⍵}∊(cJSON Results))⎕NPUT xinO,'CITA.log.json'
    ∇

    ∇ info txt;x
⍝TODO: better name (or remove it alltogether)...
      :If DEBUG
          x←⎕SE.UCMD'output.find off'
          ⎕←(,'ZI4,<->,ZI2,<->,ZI2,< >,ZI2,<:>,ZI2,<:>,ZI2,<.>,ZI3'⎕FMT 1 7⍴⎕TS),', @',({6::'' ⋄ (⍕⎕AI[3]-⍎⍵),'ms, '}'ai3'),(2⊃⎕SI),'[',(⍕2⊃⎕LC),']: ',txt
          ai3←⎕AI[3]
          {}⎕SE.UCMD'output.find ',4↓x
      :EndIf
    ∇

    ∇ {ns}←TestRepo arg;fld;fl;loc;xin;rc;specs;R;step;specsObj;lg;cnt;list;showedIO;log;del;list2;v;xin∆;jlog;cfg;rcTest;interpreters;interpreter;t;int;resTab;plus;V;B;b;E;xinO;lint;dot;item;wd;args;url;sha;stages;cmdline_s;configfile;sdir;repo;platform;version;file_s;stage;file;job;cmdline;FixPath;rc1;aplv;log1;res;org;dcwd;home;hasCITA;lb;jenk;p1;EXTRAS;BITS;EDITIONS;EXTRA_i;EXTRA;EXTRAS_i;EDITION;dyalogversions;name;type;n1;cmdlinePre;dir;to;pth;jobName;fapl;html;rc∆;ht;xinD;cfgt;versions;platforms;tests;jns;BIT;sdirD;intro;fi;z;ro;c;d;repoURL;ul
⍝:: Test a remote GitHub-repository
⍝?: Test a remote GitHub-repository
⍝?:
⍝?: ]TestRepo [URL]|[org repo]    -branch=<id>  -tag=<id>   -commit=<sha> -pull∊0123456789 [-keep[∊RCcr]] -keeponfailure[∊RCcr] [-int[=180U64...] -jenkins -off -nomail -platforms=aix|mac|pi|win|linux
⍝Parse:        1-2L               -branch=      -tag=       -commit=      -pull∊0123456789  -keep[∊]RCcr  -keeponfailure[∊]RCcr  -int[∊]"0123456789UCuc_/,.~-all"   -jenkins -off -nomail -platforms=
⍝??: Test a remote GitHub-repository
⍝??:
⍝??: ]TestRepo [URL]|[org repo]    -branch=<id>  -tag=<id>   -commit=<sha> -pull∊0123456789 [-keep[∊RCcr]] -keeponfailure[∊RCcr] [-int[=180U64...] -jenkins -off -nomail -nomail -platforms=aix|mac|pi|win|linux
⍝??: <URL>                URL of a repo (can also be a URL of a commit or tag or branch or PR as taken from your browser)
⍝??: <org>                name of an organization (i.e. "dyalog" - which is also the default)
⍝??: <repo>               name of a repo (i.e. "CITA")
⍝??: -jenkins indicates that we are supposed to create the Jenkins jobs that execute the tests on platforms & interpreters
⍝??: -off     exit APL after running test
⍝??; -nomail  do not send status mail (if configured in CITA.json[5] in the repository).
⍝A?: Error codes (ns.rc):
⍝A?: 0 - ok (tests succeeded)
⍝A?: 1 - tests were excuted and we had saw at least one test not succeeding
⍝A?: 2 - could not validate Jenkins job
⍝A?: 101 - Problem "getting" repository (Details in ns.Log)
⍝A?: 101 - Problem "getting" repository (Details in ns.Log)
⍝A?: 102 - Problem "getting" test-specs (Details in ns.Log)
⍝A?: 103 - No APL found to test against (Details in ns.Log)
⍝A?: 104 - Internal problem
⍝A?: 105 - Empty STAGES (no valid versions/platforms etc. found)
⍝A?: 106 - no tests executed
     
      _InitUCMDs
      _ai3←⎕AI[3]
      ns←⎕NS''
      ns.Log←⍬
      ns.rc←¯1
     
      hlp←∨/('-?'⍷⍕arg)                        ⍝ remember if user asked for help
      arg←##._Parse arg
      :If hlp                                   ⍝ if he asked for help
          ns.(rc Log)←0 arg                     ⍝ return it (Parse will have put it into its result!)
          →0                                    ⍝ and exit
      :EndIf
     
      fl←1 ''##._getArg 1 arg
      fl←{(~⎕NEXISTS ⍵)∨'http'≡4↑⎕C ⍵:⍵ ⋄ ∊1 ⎕NPARTS ⍵}fl  ⍝ fld=folder, fl=path to a CITA.json
      sha←''
      repoURL←''    ⍝ if we use a repository and it has a URL
      ai3←⎕AI[3]
      info' Started'
      :If 0≡arg._2          ⍝ only one argument - the name of a dyalog-repository
          arg.(_2←_1)       ⍝ rearrange arguments
          arg._1←'Dyalog'   ⍝ and assign default org
      :EndIf
     
     
      :If 'http'≡⎕C 4↑fl  ⍝ if a URL is given
          :If ~##.GitHub.HasCITA fl
              ns.rc←102
              ns.Log←⊂'Repository ',fl,' does not contain CITA.json[5]'
              →Exit
          :EndIf
          fl←'/'(≠⊆⊢)(7+'s'=5⊃fl)↓fl   ⍝ elements of the URL
          :If 'github.com'≢⎕C 1⊃fl
              ns.rc←101
              ns.Log←⊂'Domain ("',arg._1,'") of URL did not match "github.com"'
              →Exit
          :EndIf
          fl←1↓fl  ⍝ remove domain
          repoURL←fl
          ⎕←'fl='
          ⎕SE.Dyalog.Utils.display fl
          arg.(_1 _2)←fl[1 2]
          :If 2<≢fl                               ⍝ if there's more than
              :If 'commit'≡3⊃fl
                  arg.commit←4⊃fl
              :ElseIf 'tree'≡3⊃fl
                  arg.branch←4⊃fl
              :ElseIf 'pull'≡3⊃fl
                  :If 4≤≢fl
                  :AndIf ∧/(4⊃fl)∊⎕D
                      arg.pull←4⊃fl
                      url←'https://api.github.com/repos/',arg._1,'/',arg._2,'/pulls/',⍕arg.pull
                      R←'head.sha'##.GitHub.GetPagedResults url
                      sha←2⊃,R
                  :Else
                      ns.rc←101
                      ns.Log←⊂'Could not identify PR'
                      →Exit
                  :EndIf
              :ElseIf 5=≢fl
              :AndIf 'tag'≡4⊃fl
                  arg.tag←5⊃fl
              :EndIf
          :EndIf
      :ElseIf ∨/'/\'∊fl   ⍝ it's a local path!
          :If 'cita.json'≢⎕C 9↑3⊃⎕NPARTS fl  ⍝ does it point to a CITA.json directly?
              fl←fl,(~'\/'∊⍨⊢/fl)/'/'   ⍝ try to interpret it as proper folder
          :AndIf (~⎕NEXISTS fl,'CITA.json')∧~⎕NEXISTS fl,'CITA.json5'  ⍝ or to a folder that contains such a file?
              ns.rc←102
              ns.Log←⊂'Folder ',fl,' does not contain CITA.json[5]'
              →Exit
          :EndIf
          hasCITA←1
          arg._2←2⊃⎕NPARTS⊃⊃0(⎕NINFO ⎕OPT'Wildcard' 1)¯1↓1⊃⎕NPARTS fl
          :If ⎕NEXISTS fl,'/.git/config'
              c←1⊃⎕NGET(fl,'/.git/config')1
              :If (ro←c⍳⊂'[remote "origin"]')<≢c
                  z←⊃⍸(ro<⍳≢c)∧∊'['=1↑¨c
                  d←'|'(≠⊆⊢)⊃('\s*url\s*=\s*git@(.*):(.*)/(.*).git\s*'⎕S'\1|\2|\3')ro↓z↑c
                  repoURL←¯1↓∊d,¨'/'
                  arg.(_1 _2)←d[2 3]
              :Else
                  ⎕←'Found no sction "[remote "origin"]" in ',fl,'/.git/config'
              :EndIf
          :EndIf
      :Else   ⍝ name of repo was given
          hasCITA←0
          :If arg.pull≢0
              url←'https://api.github.com/repos/',arg._1,'/',arg._2,'/pulls/',⍕arg.pull
              hasCITA←##.GitHub.HasCITA url
          :Else
              url←'https://api.github.com/repos/',arg._1,'/',arg._2
              hasCITA←⎕NEXISTS(_getConfig'GETREPOSFROM'),arg._2,'/CITA.json5'
          :EndIf
          :If ~hasCITA
          :AndIf arg._2{0=≢⍵:1 ⋄ ~⎕NEXISTS ⍵,⍺,'/CITA.json5'}_getConfig'GETREPOSFROM'   ⍝ optional, may define local path to a git (which has subfolders for CITA and DBuildTest)
          :AndIf ~##.GitHub.HasCITA arg.(_1 _2)
              ns.rc←102
              ns.Log←⊂'Repository ',(∊arg.(_1'/',_2)),' does not contain CITA.json[5]'
              →Exit
          :EndIf
          fl←(_getConfig'GETREPOSFROM'),arg._2
          :If ⎕NEXISTS fl,'/.git/config'
              c←1⊃⎕NGET(fl,'/.git/config')1
              :If (ro←c⍳⊂'[remote "origin"]')<≢c
                  z←⊃⍸(ro<⍳≢c)∧∊'['=1↑¨c
                  ul←⊃('\s*url\s*=\s*(.*).git\s*'⎕S'\1')ro↓z↑c   ⍝ get the line with the url-assignment
                  ⍝ extract domain / org / repo from url
                  ⍝ I saw two different formats that need different extractions:
                  :If 'https://'≡8↑ul
                    ⍝ 1: url = https://github.com/Dyalog/conga-apl.git
                      d←'|'(≠⊆⊢)⊃('https://(.*)/(.*)/(.*)\s*'⎕S'\1|\2|\3')ul
                  :Else
                    ⍝ 2: url=url = git@github.com:mbaas2/tmp.git
                      d←'|'(≠⊆⊢)⊃('git@(.*):(.*)/(.*)\s*'⎕S'\1|\2|\3')ul
                  :EndIf
                  repoURL←¯1↓∊d,¨'/'
                  arg.(_1 _2)←d[2 3]
              :Else
                  ⎕←'Found no section "[remote "origin"]" in ',fl,'/.git/config'
              :EndIf
          :EndIf
     
      :EndIf
⍝ TODO: get CITA from web (or locally, that needs to be added above 721) and is used below (search SendMail)
      :If 0=≢sha
      :AndIf 0<≢repoURL
          q←''
          :If 0≢arg.branch
              q←'?branch='arg.branch
          :EndIf
          q←q,((1+0<≢q)⊃'?&'),'sort=created&direction=desc'
          url←'https://api.github.com/repos/',arg._1,'/',arg._2,'/commits',q
          R←'sha'##.GitHub.GetPagedResults url
          sha←2⊃,R
      :EndIf
     
     
⍝ create tempdir for stuff downloaded from repo
      :If arg.jenkins
        ⍝  (rc log)←⎕SE.CITA.JenkinsConnection.Run''
        ⍝   ns.Log←log
        ⍝   ns.rc←rc
        ⍝   →0
          home←##.Home
          EnableRIDE←0   ⍝ do we want to RIDE into the CITA job?
          arg.platforms←','(≠⊆⊢){⍵≡0:'' ⋄ ⍵}arg.platforms
⍝TODO: add these to parse & doc. also add versions!
⍝arg.editions←{⍵=⍥⎕c'u': 'unicode' ⋄ ⍵=⍥⎕c'c': 'classic' ⋄ ⍵}¨','    (≠⊆⊢)arg.editions
⍝arg.bits←{' '=⍥⎕dr ⍵:2⊃⎕vfi ⍵ ⋄ ⍵}','(≠⊆⊢)arg.bits
     
          (org repo)←arg.(_1 _2)
          :If 0=≢dcwd←_getConfig'WORKDIR'
              ns.rc←105
              ns.Log←'Environment variable (or config setting) "WORKDIR" not found!'
              →Exit
          :EndIf
          wd←dcwd,(~∨/'\/'∊⊢/dcwd)/'/'  ⍝ make sure path ends with '/'
          :If ~⎕NEXISTS dcwd
              ns.rc←105
              ns.Log←'WORKDIR not set or invalid! (Value="',dcwd,'")'
              →Exit
          :EndIf
          jobName←repo,'_',arg{0::2⊃⍵ ⋄ ⍺⍎⍵}'branch' 'main'
          ⍝xinO←∊1 ⎕NPARTS wd,,('ZI4,ZI2,ZI2,<_>,ZI2,ZI2,ZI2,</',repo,'/>')⎕FMT 1 6⍴⎕TS   ⍝ create name for subfolder of our test
          xinO←∊1 ⎕NPARTS wd,jobName,,('</>,ZI4,ZI2,ZI2,<_>,ZI2,ZI2,ZI2,</>')⎕FMT 1 6⍴⎕TS
          :While ⎕NEXISTS xinO   ⍝ if that folder exists...
              xinO←{~'_'∊¯3↑⍵:⍵,'_1' ⋄ i←⌈/⍸⍵='_' ⋄ ⍵[⍳i],⍕1+2⊃⎕VFI i↓⍵}xinO    ⍝ append a counter to make it unique...
          :End
        ⍝   :Trap 0
          3 ⎕MKDIR xinO   ⍝ create it
     
          d←⎕NS''
          d.state←'pending'
          d.description←'CITA is running tests (',xinO,')'
          d.context←'CITA'
          {}d ##.GitHub.SetStatus arg.(_1 _2),⊂sha
     
        ⍝   :Else
        ⍝       ⎕←'Error while attempting to create subfolder for test: ',xinO
        ⍝       ⎕←↑⎕DM
        ⍝   :EndTrap
⍝ Variable xinD has parent of xinO, but based on the /devt/-drive, whereas xinO may have U: when called from a networked PC.
⍝ Using xinD is an alternative to referring to $citaDEVT.
     
          :If 'u:'≡⎕C 2↑xinO
              xinD←'u:',2↓xinO
          :ElseIf '/devt/'≡(d←6)↑xinO
          :OrIf '/Volumes/devt/'≡(d←14)↑xinO
              xinD←'u:/',d↓1⊃⎕NPARTS xinO
          :Else
              ns.rc←104 ⍝ TODO: return code!
              ns.Log←⊂'xinO on unexpected location!'
              →Exit
          :EndIf
        ⍝   ⎕←'xinO=',xinO
        ⍝   ⎕←'xinD=',xinD
          3 ⎕MKDIR xinO,'CITA'
⍝ 675 and below
          :If 0=≢res←_getConfig'GETREPOSFROM'   ⍝ optional, may define local path to a git (which has subfolders for CITA and DBuildTest)
          :OrIf 'git'≡⎕C res
          :OrIf ~⎕NEXISTS res
              :If 0≠⊃res←(xinO,'CITA/')##.GitHub.GetFilesFromSHA'Dyalog' 'CITA'
                  ns.rc←101
                  ns.Log←⊂'Download of CITA repo failed with',2⊃res
                  →Exit
              :EndIf
     
⍝ get the last version of DyalogBuild.dyalog to ensure that we interpreters will use the latest version of ]DTest
              info'Retrieving DyalogBuild.dyalog from GitHub'
              :If 0≠⊃res←(xinO,'CITA/SALT/spice/DyalogBuild.dyalog')##.GitHub.RetrieveFile'https://raw.githubusercontent.com/Dyalog/DBuildTest/master/DyalogBuild.dyalog'
                  ns.rc←101
                  ns.Log←⊂'Download of DBuildTest repo failed with',2⊃res
                  →Exit
              :EndIf
              rc1←(xinO,repo)##.GitHub.GetFilesFromSHA org repo ⍝sha
          :Else
          ⍝ get these from a local git folder (so we won't need to commit anything that we want to test to Git
              ⍝_CopyFolder'Collect'
              info'CopyFolder ',res,'CITA → xinO' ⋄ (xinO,'CITA/')_CopyFolder res,'CITA/'
              info'CopyFolder ',res,repo ⋄ (xinO,repo,'/')_CopyFolder res,repo,'/'
              info'Copy DyalogBuild.dyalog' ⋄ (xinO,'CITA/SALT/spice/DyalogBuild.dyalog')⎕NCOPY res,'DBuildTest/DyalogBuild.dyalog'
              rc1←,0
          :EndIf
     
          :If 0≠1⊃rc1
              ns.rc←101
              ns.Log←⊂'Error retrieving repo: ',∊1↓rc1
              →Exit
          :EndIf
⍝          rd←1⊃1(⎕NINFO⎕opt'Wildcard' 1)xinO,'*.*'
          (rc1 cfgt log1)←_GetTestSpecs cita_file←∊(⊂xinO,repo,'/'){⎕NEXISTS r←⍺,⍵:r ⋄ ⍬}¨'CITA.json' 'CITA.json5'
          :If rc1≠0
              ns.Log←⊂'Error retrieving test specs: ',log1
              ns.rc←102
              →Exit
          :EndIf
          dyalogversions←(⎕JSON ⎕OPT'Dialect' 'JSON5')1⊃⎕NGET home,'dyalogversions.json5'
          aplv←dyalogversions.versions
          fapl←⊃∪/FilterAPLVersions¨(cfgt{0=⍺.⎕NC ⍵:'' ⋄ ⍺⍎⍵}¨⊂'dyalogversions'),¨⊂' -list=',¯1↓∊aplv,¨','   ⍝ all versions we need to run on
          :If 0=≢fapl
              ns.Log←'No APLVersion found to test this repository against!'
              ns.rc←103
              →Exit
          :EndIf
          info'fapl=',fapl
          FixPath←{⍺←0 ⋄ ('u:/'⎕R((⍺+1)⊃'/devt/' '[citaDEVT]' '${citaDEVT}')⎕OPT('Regex' 0)('IC' 1))⍵}   ⍝ translate U: to /devt/
⍝ use a CONFIGFILE from the parent folder of WORKDIR
          cfg←⎕NS''
          cfg.Settings←⎕NS''
          cfg.Settings.CITA_SRCDIR←1 FixPath xinD,'CITA'
          cfg.Settings.DEFAULT_PW←400
     
⍝ why was this needed?
⍝          (xinO,'CITA/client')(⎕NCOPY ⎕OPT'IfExists' 'Replace')((_getConfig'SRCDIR'),'/client/Executor.dws')
          cmdlinePre←''
          cmdline←2 FixPath xinD,'CITA/client/Executor'    ⍝ .dws' don't specify extension to avoid failure if DWS
     
          :If EnableRIDE
              cfg.Settings.RIDE_INIT←'HTTP:*:4505'
              cmdlinePre←'export TERM=dumb;'
              cmdline←'+s ',cmdline
          :EndIf
          cmdline,←' ENABLE_CEF=0'
        ⍝   cmdline,←' DYALOGSTARTUPSE=',2 FixPath xinD,'CITA/StartupSession/'
          cmdline,←' COMMANDFOLDER=',2 FixPath xinD,'CITA/SALT/spice/'
          LOGFILES←⍬
     
     
          info'Generating jobdef'
          :If ⎕NEXISTS file←##.Home,'/Jenkins/jobTemplate.xml'
              job←1⊃⎕NGET file
              job←('%xinD%'⎕R(2 FixPath xinD)⎕OPT'Regex' 0)job
              STAGES←''
     
              :For platform :In arg.platforms{0=≢⍺:⍵ ⋄ ⍺∩⍵}dyalogversions.platforms{6::⍺ ⋄ ⍺∩⍥⎕C(⊃⍤1)⍎⍵}'cfgt.platforms'  ⍝  'mac' 'pi'  ⍝ 'win' 'linux' ⍝ TODO: maybe CITA.json5 should specify the platforms?
                  ⍝intro←('stage("',platform,'&&%CITA_VERSION%"){') '  agent{' ('    label "',platform,'&&%CITA_VERSION%"') '  }' '  steps{' '    script{'
                  ⍝intro←('stage("',platform,'&&%CITA_VERSION%"){') '  agent{' ('    label "',platform,'&&%CITA_VERSION%"') '  }' '  steps{' '    catchError(buildResult: "UNSTABLE", stageResult: "FAILURE") {' '      script{'
⍝ Platform win has label"Windows" with Jenkins
                  intro←⊂'stage (''',{'win'≡⎕C ⍵:'Windows' ⋄ ⍵}platform,''') {'
                  intro←intro,(platform≢'linux')/'  steps {' '    script {'
                  :If ⎕NEXISTS fi←(1⊃⎕NPARTS file),'/stageintro.',platform,'.groovy'
                      intro,←(⊂'      '),¨1⊃⎕NGET fi 1
                  :Else
                      intro,←(⊂'      '),¨1⊃⎕NGET((1⊃⎕NPARTS file),'/stageintro.groovy')1
                  :EndIf
                  stage←''
     
                  EDITIONS←dyalogversions.editions
                  :If 9=dyalogversions.⎕NC'platforms_editions'
                  :AndIf 2=dyalogversions.platforms_editions.⎕NC platform
                      EDITIONS←⊆dyalogversions.platforms_editions.⍎platform
                  :EndIf
     
                  BITS←dyalogversions.bits
                  :If 9=dyalogversions.⎕NC'platforms_bits'
                  :AndIf 2=dyalogversions.platforms_bits.⎕NC platform
                      BITS←dyalogversions.platforms_bits⍎platform
                  :EndIf
     
                  EXTRAS←''
                  :If 9=dyalogversions.⎕NC'platforms_extras'
                  :AndIf 2=dyalogversions.platforms_extras.⎕NC platform
                      EXTRAS←⊆dyalogversions.platforms_extras⍎platform
                  :EndIf
     
                  file_s←(∊2↑⎕NPARTS file),'-stages-',platform,'.groovy'  ⍝ the stage-file for that platform
                  :If ⎕NEXISTS file_s
                      ThisStage←1⊃⎕NGET file_s 1
                      :For version :In fapl
                          :For BIT :In BITS
                              :For EDITION :In ⊆EDITIONS
                                  :For EXTRA :In ⊆EXTRAS
                                      sdir←xinO,{⍵∩('_.-/',⎕D,⎕A,⎕C ⎕A)}(platform,{1<≢⍵:'-',⍵ ⋄ '_'}EXTRA,'_'),version,EDITION[1],(⍕BIT),'/'
                                      3 ⎕MKDIR sdir,repo ⍝ create subfolder for repo
                                      configfile←sdir,'cita.dcfg'
                                      sdirD←xinD,(⍴xinO)↓sdir
                                      cfg.Settings.RunUCMD←'ExecuteLocalTest ',(1 FixPath xinD,repo,'/',(∊1↓⎕NPARTS cita_file)),' -workdir=',(1 FixPath sdirD),({(⍵≢⍥,'*')/' -keep=',⍵}'*'arg.Switch'keep'),({(⍵≢⍥,'*')/' -keeponfailure=',⍵}'*'arg.Switch'keeponfailure')
                                      cfg.Settings.APLCORENAME←sdir,(¯1↓{(1=⌽+\⌽⍵='/')/⍵}sdir),'_CITA_core'
                                      ⍝LOGFILES,←⊂sdir,repo,'/CITA.log'
                                      LOGFILES,←⊂sdir,'CITA.log'
     
                                      :If 'win'≡⎕C platform  ⍝ tweaks for win, suggested by AS, 210819
                                          cfg.Settings.DYALOG_NOPOPUPS←1   ⍝
                                          cfg.Settings.PASSEXCEPTIONSTOOPSYS←0
                                      :EndIf
                                      (⊂cJSON cfg)⎕NPUT configfile
                                  :EndFor
                              :EndFor
                          :EndFor
                        ⍝   ⎕←'cmdline=',cmdline
                          stage,←('%xinD%' '%VERSION%' '%CMDLINE%' '%CMDLINEPRE%' '%BITS%' '%EDITIONS%' '%EXTRAS%' '%PLATFORM%'⎕R((2×'linux'≢platform)FixPath xinD)(version)(cmdline)(cmdlinePre)({0=≢⍵:'' ⋄ ¯1↓∊(⍕¨⍵),¨','}BITS)({0=≢⍵:'' ⋄ ¯2↓∊'''',¨⍵,¨⊂''', '}EDITIONS)({0=≢⍵:'' ⋄ ¯1↓∊'"',¨⍵,¨⊂'",'}EXTRAS)platform ⎕OPT'Regex' 0)(ThisStage)
                          intro←('%xinD%' '%VERSION%' '%CMDLINE%' '%CMDLINEPRE%' '%BITS%' '%EDITIONS%' '%EXTRAS%' '%PLATFORM%'⎕R((2×'linux'≢platform)FixPath xinD)(version)(cmdline)(cmdlinePre)({0=≢⍵:'' ⋄ ¯1↓∊(⍕¨⍵),¨','}BITS)({0=≢⍵:'' ⋄ ¯2↓∊'''',¨⍵,¨⊂''', '}EDITIONS)({0=≢⍵:'' ⋄ ¯1↓∊'"',¨⍵,¨⊂'",'}EXTRAS)platform ⎕OPT'Regex' 0)(intro)
                          :If 326=⎕DR∊stage ⋄ ∘∘∘
                          :EndIf
                      :EndFor
                  :Else
                      ns.Log,←⊂'Skipped platform "',platform,'" - no stage-file with platform-specific code found. (Looked for ',file_s,')'
                  :EndIf
                  STAGES,←intro,((⊂'     '),¨stage),'    }'
                  STAGES,←(platform≢'linux')/'  }' '}'
                  :If 326=⎕DR∊STAGES ⋄ ∘∘∘
                  :EndIf
              :EndFor
              :If 0=≢STAGES
                  ns.Log←'Empty STAGES - nothing to do! (Check your filters)'
                  ns.rc←105
                  →0
              :EndIf
              p1←⍸∊'%STAGES%'⍷job  ⍝ search string that we will replace with content of var "stages"
              lb←¯1+p1-⌈/⍸((⎕UCS job)∊10 13)∧(⍳≢job)<p1  ⍝ leading blanks of lines (so that we can maintain indent)
              job←((p1-lb)↑job),(∊(⊂lb⍴' '),¨STAGES,¨NL),{(+/∧\⍵∊⎕UCS 10 13)↓⍵}(p1{⊃(⍵>⍺)/⍵}⍸(⎕UCS job)∊10 13)↓job
              file←xinO,∊1↓⎕NPARTS file
              (⊂job)⎕NPUT file
              info'Wrote job to ',file
              jenk←⎕NEW ##.JenkinsConnection('' '') ⍝((1⊃⎕NPARTS file),'httpcommand.log'))
              jenk.(Debug Cleanup)←1 0
              jf←⊃('<script>(.*)</script>'⎕S'\(1)'⎕OPT('Mode' 'M')('DotAll' 1))job
              (⊂jf)⎕NPUT(∊2↑⎕NPARTS file),'.jenkinsfile'
              :If ~⊃z←jenk.Validate jf
                  ns.Log←'Could not validate job: ',2⊃z
                  ns.rc←2
                  →0
              :EndIf
            ⍝   info'Copying stuff'
            ⍝   _CopyFolder'DoIt'
            ⍝   info'End of copy'
     
     
     
     
              jenk.LOCKFILE←{⍵(2 FixPath{('/'@('\'∘=))⍵}⍵)}wd,jobName,'.lock-jenkins'
            ⍝   lb←⊃⌽'/'(≠⊆⊢)1⊃⎕NPARTS ¯1↓xinO
              info'Launching job'
              jns←file jenk.RunJob jobName
     
              (⊂jns.log)⎕NPUT((∊2↑⎕NPARTS file),'.log')1  ⍝ save the log (temp)  TODO: remove!
              info'Done. Saved log.'
     
              ns.Log,←⊂'Executing job as defined in ',file
              ⍝ns.Log,←'BEGIN of Jenkins log',NL,log,NL,'END of Jenkins log',NL
              platforms←{'_'(≠⊆⊢)⍵[⍳¯1+⍵⍳'/']}¨(≢xinO)↓¨LOGFILES
              versions←{2⊃⍵}¨platforms
              platforms←{1⊃⍵}¨platforms
              tests←{
                  0::' '
                  ((⎕JSON ⎕OPT'Dialect' 'JSON5')1⊃⎕NGET ⍵,'.json').⎕NL ¯9
              }¨LOGFILES
              :If 3=|≡tests
                  tests←⊃,/tests
              :EndIf
            ⍝   ⎕←'LOGFILES'
            ⍝   ⎕←LOGFILES
            ⍝   ⎕←'tests'
            ⍝   ⎕SE.Dyalog.Utils.display tests
            ⍝   ∘∘∘
              tests←2↓¨∪tests~⊂' '
              :If 0=≢tests
                  ns.rc←106
                  ns.Log←'No tests were executed'
                  →0
              :EndIf
              vt←((≢tests)/∪versions),[0.5](×/≢¨tests(∪versions))⍴tests
              resTab←((⊂''),(⊂''),∪platforms),vt⍪((≢∪platforms),¯1↑⍴vt)⍴' '
              rc∆←0
              tit←'CITA-Log of test ',xinO,' (%lbl%)'
              html←'<html>',NL
              html,←' <head>',NL
              html,←'  <meta charset="utf-8">',NL
              html,←'  <meta name="viewport" content="width=device-width, initial-scale=1">',NL
              html,←'  <style>',NL
              html,←'   .ok {background-color: lightgreen;}',NL
              html,←'   .fail {background-color: lightsalmon;}',NL
              html,←'   table {border-spacing: 0; border-collapse: collapse; border: 2px solid rgb(200,200,200);}',NL
              html,←'   .legend {background-color: lightyellow; border:  2px black solid;display: inline-block;padding: 10px;}',NL
              html,←'   td {text-align: center; border: 1px solid rgb(190,190,190);padding: 10px 20px;}',NL
              html,←'   .head {background-color: lightgray; font-weight: bold;}'
              html,←'  </style>',NL
              html,←'  <title>',tit,'</title>',NL
              html,←' </head>',NL
              html,←' <body>',NL
              html,←'  <h1>',tit,'</h1>',NL
              html,←{'  <p>This is instance <a href="',⍵,'">',(⍕jns.Data.number),'</a> of job <a href="',(1⊃⎕NPARTS ¯1↓⍵),'">',(2⊃⎕NPARTS ¯1↓1⊃⎕NPARTS ¯1↓⍵),'</a></p>',NL}jns.Data.url
              html,←'  <br/>',NL
              ht←resTab
              :If 80=⎕DR' '  ⍝ unicode edition?
                ⍝ use clearer indicators for the most common types
                  ResultSymbols[1;1]←⎕UCS 10004 ⍝ success
                  ResultSymbols[2;1]←⎕UCS 10060  ⍝ ..and failure
              :EndIf
              :For i :In ⍳≢LOGFILES
                  r←(∪platforms)⍳platforms[i]
                  :Trap 22
                      s←(⎕JSON ⎕OPT'Dialect' 'JSON5')1⊃⎕NGET(i⊃LOGFILES),'.json'
                      :For t :In s.⎕NL ¯9
                          c←(↓[1]vt)⍳⊂versions[i],⊂2↓t
                          :Trap 6
                              ht[2+r;1+c]←⊂(s⍎t).outfile
                              resTab[2+r;1+c]←ResultSymbols[1+(s⍎t).rc;1]
                          :Else
                              ∘∘∘
                              ht[2+r;1+c]←LOGFILES[i]
                          :EndTrap
                      :EndFor
                  :Else
                    ⍝   ⎕←'Logfile not found: ',(i⊃LOGFILES),'.json'
                      :If DEBUG
                          ⎕←':trapped something!'
                          ⎕←cJSON ⎕DMX
                      :EndIf
                      c←(↓[1]vt)⍳⊂versions[i],(1↑tests)[1]  ⍝ assume first test...
                      :If c=¯1↑⍴resTab
                          resTab,←⊂''
                          ht,←⊂''
                      :EndIf
                      resTab[2+r;1+c]←⊂'n'
                      ht[2+r;1+c]←LOGFILES[i]
                  :EndTrap
                ⍝   ⎕←LOGFILES[i],'→ r=',r,', c=',c,', resTab=',resTab[2+2;1+c]
              :EndFor
              ns.resTab←resTab
              ht←resTab{
                  z←(⍺≢'n')∧(0<≢⍵)∧1=≢⍺
                  c←(z/'    <a href="',(_filenameToURL ⍵),'">'),⍺,z/'</a>'
                  '<td',(((⍺≢⍥,' ')∧1=≢⍺)/' class="',((1+⍺≢ResultSymbols[1;1])⊃'ok' 'fail'),'"'),'>',c,'</td>',NL
              }¨ht
              ht[1;1]←⊂'<td rowspan=2 class="head"></td>',NL
              ht[2;1]←⊂''
              ht←∊(⊂'   <tr>',NL,'    '),ht,⊂'   </tr>',NL
              ht←'  <table cellspacing="0" cellpadding="2">',NL,ht,NL
              ht,←'  </table>'
              (svg lbl)←_AddTestStatusSVG 2 1↓resTab
              html←('%lbl%'⎕R lbl)html
              tit←('%lbl%'⎕R lbl)tit
              html,←'  ',svg,NL
              html,←'  <br/><br/>',NL
              html←html,ht
              html,←'  <br /><br /><p class="legend">',({
                  0=≢∊1↓⍵:''
                  (1⊃⍵),'<br />',¯2↓∊{
                      '<b>',⍵[1],'</b>',1↓⍵,', '}¨{(∨\⍵≠' ')/⍵}¨{';'(≠⊆⊢)∊⍵
                  }1↓⍵
              }1↓_AddLegend 1 0↓resTab),'<p>',NL
     
              :If 2=jns.⎕NC'StageTab'
                  html,←'<h3>Failed stages</h3>',NL
                  html,←jns.StageTab
              :EndIf
     
              ns.Runtime←⎕AI[3]-_ai3
              info'Runtime = ',{(⍕⍵),'ms, approx. ',(⍕⌊⍵÷60000),' min'}ns.Runtime
              html,←'  <br>RunTime: ',({p←⌈10⍟⍵ ⋄ (,('CI',(⍕p+⌊p÷3),',< ms>')⎕FMT ⍵),', approx. ',(⍕⌊⍵÷60000),' min'}ns.Runtime),NL
              ds←⌊0.5+(+/⊃2(⎕NINFO ⎕OPT('Wildcard' 1)('Recurse' 1))xinO,'*')÷1024*2
              html,←'  <br>Artifacts of tests use approx. ',(⍕ds),'MB of diskspace',NL
              html,←' </body>',NL
              html←html,'</html>',NL
              (⊂html)⎕NPUT xinO,'CITA.log.html'
     
              ns.Log,←'' 'Results:',↓⍕resTab
              ns.Log,←_AddLegend 1 0↓resTab
              ns.Summary←lbl
              ns.rawTab←2 1↓resTab
              ns.rc←0+∨/(1↓ResultSymbols[;1])∊ns.rawTab
              :If ~arg.nomail
              :AndIf 0≠(1⊃cfgt).⎕NC'email'
              ⍝ TODO: SendMail (check if repo is configured to send logs by mail)
              ⍝ subject: CITA TestRepo ...: lbl
              ⍝ a vector of Server Port From [Password [Userid [Secure]]]
     
                  to←''
                  :If 80=⎕DR(1⊃cfgt).email
                      to←(1⊃cfgt).email
                  :Else
                      :If 2=(1⊃cfgt).email.⎕NC'all'
                          to←_l2v(1⊃cfgt).email.all
                      :EndIf
                      :If ns.rc=0  ⍝ test succeeded
                          :If 2=(1⊃cfgt)email.⎕NC'ok'
                              to,←(1⊃cfgt).email.ok
                          :EndIf
                      :Else        ⍝ test fails
                          :If 2=(1⊃cfgt).email.⎕NC'error'
                              to,←(1⊃cfgt).email.error
                          :EndIf
                      :EndIf
                  :EndIf
                  :If 0<≢to
                      msgArgs←⎕NS''
                      msgArgs.To←¯1↓∊(∪⊆to),¨','
                      msgArgs.Subj←tit
                      msgArgs.Body←('<h1>(.*)</h1>'⎕R'')html  ⍝ remove title tag, as we already have in the mail title
                      msgArgs.From←_getConfig'SMTP_FROM_ADDRESS'
                      clientArgs←⊂_getConfig'SMTP_SERVER'
                      clientArgs,←⊂1 _getConfig'SMTP_PORT'
                      clientArgs,←⊂_getConfig'SMTP_FROM_ADDRESS'
                      clientArgs,←⊂_getConfig'SMTP_PASSWORD'
                      clientArgs,←⊂_getConfig'SMTP_USER'
                      (rc msg server)←clientArgs _SendMail msgArgs
                      :If rc≠0
                          ⎕←'Caught error while attempting to send result to ',to
                          ⎕←'rc=',rc
                          ⎕←'msg=',msg
                          ⎕←'⎕dr html =',⎕DR html
                      :EndIf
                  :EndIf
              :EndIf
     
             ⍝ set traffic lights for repository:
              :If 0<≢repoURL  ⍝ if we have a URL
                  d←⎕NS''
                  d.state←(1+ns.rc=0)⊃'failure' 'success'
                  ⍝TODO: CITAServer muss diese Dateien ausliefern (im CITA_Results pfad)
                  ⍝ muss dann auch links zu den logs ermöglichen
                  ⍝ d.target_url←_filenameToURL xinO,'CITA.log.html'
                  d.description←lbl,' (',xinO,')'
                  d.context←'CITA'
                  r←d ##.GitHub.SetStatus arg.(_1 _2),⊂sha
                  :If r.rc≠0
                  :OrIf r.HttpStatus≠201
                      ⎕←'Error setting status of repository ',repoURL
                      ⎕←'r=',r
                      ∘∘∘
                  :EndIf
              :Else
                  ns.Log←'Could not find required "',file,'" to build Jenkins job'
                  ns.rc←104
              :EndIf
              →Exit
          :EndIf   ⍝ -jenkins
     
          xinO←(739⌶0),,('</CITA_Test/>,ZI4,ZI2,ZI2,<_>,ZI2,ZI2,ZI2,</repo/',(arg._1,'-',arg._2),'/>')⎕FMT 1 6⍴⎕TS
          3 ⎕MKDIR xinO
     
          :If 0≢arg.tag
⍝ tags come as zipballs and need to be unzipped...
              :If 0=⊃r←(xinO,'t.zip')##.GitHub.RetrieveFile'https://api.github.com/repos/',arg._1,'/',arg._2,'/zipball/refs/tags/',arg.tag
                  (2⊃r)##.GitHub.Unzip xinO
                  z←0 1(⎕NINFO ⎕OPT'Wildcard' 1)xinO,'*'
                  xinO←(1⍳⍨2⊃z)⊃1⊃z   ⍝ .zip contains all files inside a folder with unfathomable name - get that name and use it to examine that folder
              :Else
                  ns.Log←'Error attempting to retrieve zip for tag "',rag.tag,'":'
                  ns.Log,←≡r
                  ns.rc←1
                  →Exit
              :EndIf
          :Else
              :If 0≢arg.pull
                  R2←(##.GitHub._gethc url←'https://api.github.com/repos/',arg._1,'/',arg._2,'/pulls/',arg.pull).Run
                  :If R2.rc=0
                  :AndIf R2.HttpStatus=200
                      arg.commit←(⎕JSON R2.Data).head.sha
                  :Else
                      ns.rc←1
                      ns.Log←'Error retrieving PR from ',url
                      ns.Log,←⍕R2
                      →Exit
                  :EndIf
              :ElseIf 0 0≡arg.(branch commit)
  ⍝ get id of last commit to the repo
                  R2←'commit.author.date' 'sha' 'url'##.GitHub.ListCommits arg.(_1 _2)
                  R21←R2 ##.GitHub.SortListBy'commit.author.date'    ⍝ sort by date
                  sha←2⊃R2[2;]  ⍝ find last commit
                  arg.commit←sha
              :EndIf
              :If 0≡arg.commit   ⍝ if commit was not selected
                  b←'name' 'commit.url'##.GitHub.ListBranches arg.(_1 _2)
                  :If 1=≡b
                      ns.rc←2
                      ns.Log←'Could not query repository "',arg.(_1,'/',_2),'"'
                      →Exit
                  :EndIf
                  :If (≢b)<bi←b[;1]⍳⊂arg.branch
                      ns.rc←3
                      ns.Log←'Could not find branch "',arg.branch,'" of repository "',arg.(_1,'/',_2),'"'
                      →Exit
                  :EndIf
                  sha←{(⌽∧\⌽⍵≠'/')/⍵}2⊃b[bi;]
                  arg.commit←sha
              :EndIf
              r←xinO ##.GitHub.GetFilesFromSHA arg.(_1 _2 commit)
          :EndIf
          :If 0=1⊃r       ⍝ if that ended ok
          :AndIf ×≢2⊃r     ⍝ and if we got any files from it
              wd←1⊃⎕NPARTS ¯1↓1⊃⎕NPARTS ¯1↓xinO
              fl←⊃0(⎕NINFO ⎕OPT('Recurse' 2)('Wildcard' 1))xinO,'CITA.json*'
     
              args←{('*'≢⍥,⍵)/' -keep="',⍵,'"'}'*'arg.Switch'keep'
              args,←{('*'≢⍥,⍵)/' -keeponfailure="',⍵,'"'}'*'arg.Switch'keeponfailure'
              args,←{(0<≢⍵)/' -int',(⍵≢1)/'=',⍵}''arg.Switch'int'
              args,←' -ucmd=0 -workdir="',wd,'"'
              ns←ExecuteLocalTest(1⊃fl),args   ⍝ pass-through the result...
          :EndIf
     Exit:
          :If 0=⎕NC'xinO'
          :OrIf ~⎕NEXISTS xinO
              →0
          :EndIf
          (⊂(⎕JSON ⎕OPT('Compact' 0)('HighRank' 'Split'))ns)⎕NPUT xinO,'CITA.log.json'
    ⍝   :If arg.off
    ⍝       ⎕OFF 42   ⍝ 42 indicates "regular exit"
    ⍝   :EndIf
      :EndIf
    ∇

    :section tools
    ∇ ns←step _RunJob cfg_specs_interpreter;cpu;dws;cmd;ext;proc;StatusFiles;ai3;log;specs;cfg;file;isDTest;Fullname;t;TestLog;exited;WSFULL;lg;ai31
⍝ returncode: 0=ok
⍝             1=test failed
⍝             2=aborted because of Timeout
⍝             3=no status file found
⍝             4=invalid or non-existent file
⍝             5=APL errors executing test
⍝             6=executing test ended with APLCORE
⍝             7=WS FULL
⍝             8=Likely TRANSLATION ERROR
⍝ access global var "V" which has the APL-Version of the target-environment as a numeric value
⍝ access global var "E" which has the Edition of the target-environment (U|C)
      ns←⎕NS''
      ns.log←''
      dws←cmd←''  ⍝ Arguments for constructor of APLProcess
      ns.R←0
      →(0=≢cfg_specs_interpreter)/EOF
      (cfg specs interpreter)←3↑⊆cfg_specs_interpreter
      file←specs{6::'' ⋄ ⍺⍎⍵}step
      →(0=≢file)/EOF
      isDTest←0   ⍝ do we have a ]DTest-Call?
      :If ~⎕NEXISTS xin,file
          ns.R←4
          :If (⎕C∊1 ⎕NPARTS file)≡⎕C file
              ns.log←'Absolute reference to file "',file,'" found in specs for tests - CITA expects paths that are relative within the repository!'
          :Else
              ns.log←'File "',xin,file,'" not found!'
          :EndIf
          →EndJob
      :EndIf
     
    ⍝ step of Statusfiles to indicate APL Errors [1], failure [2] or success[3]
      StatusFiles←(⊂xin,'CITA.',⎕C step),¨'.err' '.fail' '.ok'
      ⎕←'StatusFiles←'
      ⎕SE.Dyalog.Utils.display StatusFiles
      1 ⎕NDELETE¨StatusFiles  ⍝ make sure there are no old statusfiles around...
     
      cfg,←' CITA_Log="',(∊2↑⎕NPARTS 1⊃StatusFiles),'"'
      cfg,←' APLCORENAME="',(aplcore←xin,({¯1↓(2=⌽+\⌽⍵='/')/⍵}xin),'_CORE_',step,'.'),'"'
    ⍝   ⎕←'xin=',xin
    ⍝   ⎕←'APLCORENAME=',aplcore
      :If 0<≢t←2 ⎕NQ'.' 'GetEnvironment' 'COMMANDFOLDER'
          ⍝ if CMDFOLDER was set when we were called...
          cfg,←' COMMANDFOLDER="',t,'"'   ⍝ let the process use it, too
      :EndIf
      :If ⎕SE.SALTUtils.WIN   ⍝ if we're running under Windows
      ⍝ add those flags to better deal with possible exceptions...
          cfg,←' DYALOG_NOPOPUPS=1 PassExceptionsToOpSys=1'
      :EndIf
      cfg,←' CITADEBUG=',⍕DEBUG
      cfg,←' CITA_SRCDIR=',∊1 ⎕NPARTS xin,'../../CITA/'
     
      cpu←⎕AI[3]
      Fullname←∊1 ⎕NPARTS xin,file
      :Select ext←⎕C 3⊃⎕NPARTS file
      :CaseList '.aplf' '.aplc' '.dyalog'
          TestLog←xin,'CITA_',(2⊃⎕NPARTS(-(ext≡''))↓Fullname),'.log'
          cmd←'CITATest="',Fullname,'" testlog="',TestLog,'"'
        ⍝  cmd←'CITATest="',Fullname,'"'
          dws←∊1 ⎕NPARTS ##.Home,'/client/Executor'
      :Case '.dws' ⋄ dws←Fullname
      :CaseList '' '.dyalogtest'
          R←4('.dyalogtest or folder-argument only valid for "test", not "',step,'"') ⋄ →(step≢'test')/EndJob
          :If ext≡'' ⋄ :AndIf 1≠1 ⎕NINFO Fullname ⋄ R←4 ⋄ →EndJob ⋄ :EndIf  ⍝ no extension, but does not refer to a folder
          TestLog←xin,'CITA_',(2⊃⎕NPARTS(-(ext≡''))↓Fullname),'.log'
          cmd←'CITATest="',Fullname,'"  testlog="',TestLog,'" ',specs{6::'' ⋄ 'dtestmods="',(⍺⍎⍵),'"'}'dtestmodifiers'
        ⍝   cmd←'CITATest="',Fullname,'" ',specs{6::'' ⋄ 'dtestmods="',(⍺⍎⍵),'"'}'dtestmodifiers'
          dws←'"',∊1 ⎕NPARTS ##.Home,'/client/Executor"'
          isDTest←1
      :Else
          ns.(R log)←4('Did not recognize type of file "',file,'"') ⋄ →EndJob
      :EndSelect
      outfile←xin,'output.txt'
      ns.outfile←outfile
      cmd,←' ',cfg
      exited←¯1
    ⍝  ⎕trap←0'S'⋄600⌶1
    ⍝  ∘∘∘
    ⍝  600⌶0
      :If ∨/'classic'⍷⎕C interpreter
          cmd,←' DYALOG_NETCORE=0'    ⍝ make sure that we don't attempt to use .NET Core
      :EndIf
      WSFULL←0  ⍝ has the test hit a WS FULL?
      GhostRiderFlag←0  ⍝ 0=don't use it at all, 1=use CitaRider (a specifically tailored variant of Ghostrider) to deal with APLProcess
      gr←0
      :Select GhostRiderFlag
      :CaseList 0 1
          :If GhostRiderFlag=1
              cmd,←' WFR=1' ⍝ WFR=WaitForRide → if Executor sees this, it will wait until GhostRider has connected
          :EndIf
          ⍝ assign a free port
          tmp←⎕NEW ⎕SE.CITA.CITARider'INIT'
          port←tmp.GetTcpPort
          ⎕EX'tmp'
         ⍝ :If DEBUG ⋄
          ⎕←' Creating new APLProcess. dws=',dws
          ⎕←'cmd=',cmd
          ⎕←'outfile=',outfile,' | xin=',xin,', RIDE_INIT=serve:127.0.0.1:',(⍕port)
        ⍝  :EndIf
          proc←⎕NEW ##.APLProcess(dws cmd(interpreter{0::0 ⋄ ⍺⍎⍵}'exe')('serve:127.0.0.1:',⍕port)outfile xin) ⋄ ai3←⎕AI[3]
          proc.psLogFile←xin,'/pslog.txt'
              ⎕←'pid of child process: ',⍕proc.Proc.Id
              ⎕←'HasExited1: ',⍕proc.HasExited
              ⎕←'IsRunning1: ',⍕proc.IsRunning proc.Proc.Id
              ⎕←'secondstimeout=',specs.secondstimeout

          :If GhostRiderFlag=1
              ⎕DL 1  ⍝ give it some time to launch...
              :Trap 0
                  gr←⎕NEW ##.CITARider(port'127.0.0.1')
              :Else
                  ⎕←'Error setting up CITARider'
                  ⎕←cJSON ⎕DMX
                  ⎕←'⎕SE.SALTUtils.DEBUG=',⍕⎕SE.SALTUtils.DEBUG
                  ⎕←'SI=' ⋄ ⎕←⎕SI,'<[>,I3,<]>'⎕FMT ⎕LC
              :EndTrap
          :EndIf
        ⍝   :If DEBUG
        ⍝   :EndIf
    ⍝   ⎕←(1⊃⎕SI),'[',(⍕1⊃⎕LC),'] Waiting till its running'
    ⍝   :While ~proc.IsRunning proc.Proc.Id ⋄ ai3←⎕AI[3] ⋄ :EndWhile   ⍝ wait until process has started
    ⍝   ⎕←(1⊃⎕SI),'[',(⍕1⊃⎕LC),'] its running now - waiting till its finished'
          :Repeat
              ⎕DL 1⌊specs.secondstimeout×1000  ⍝ delay one second by default, but allow smaller (if someone challenges our timeouts...)
          :Until (ai31←⎕AI[3])≥⌊ai3+specs.secondstimeout×1000
          :OrIf exited←proc.HasExited
⍝          :If DEBUG
          ⎕←(1⊃⎕SI),'[',(⍕1⊃⎕LC),'] DONE! Checking results...'
          ⎕←'HasExited2: ',⍕proc.HasExited
          ⎕←'IsRunning2: ',⍕proc.IsRunning proc.Proc.Id
          ⎕←'exited='{0::'N/A' ⋄ ⍎⍵}'exited'
 ⍝         :EndIf
          :If 0=⎕NC'exited'
          :OrIf exited∊0 ¯1   ⍝ TIMEOUT
              ⎕←'Detected likely TIMEOUT!'
              :If gr≢0
                  :Trap 0
                      ⎕←'Sending interrupt'
                      gr.EmptyQueue'EmptyQueue'
                      0 gr.Send'["StrongInterrupt",{}]'
                      gr.EmptyQueue'["CloseAllWindows",{}]'
                    ⍝   5 gr.EmptyQueue'EmptyQueue'
                    ⍝   ⎕←'getting log and writing it to filename below'
                    ⍝   ⍝(⊂{⍵.APL'↑⎕SE.Log'}gr)⎕NPUT ⎕←({⍵[⍳⍵⍳'.']}1⊃StatusFiles),'sesslog.txt'
                    ⍝   ⎕trap←0/⎕trap
                    ⍝   600⌶1
                      gr{0::'' ⋄ ⍺.APL ⍵}')RESET   ⍝ sent by "CITA controller" following the interrupt'
                      gr{0::'' ⋄ ⍺.Execute'(⊂⎕se.Log)⎕nput ''',⍵,''''}({(1⊃⍵),{⍵[⍳⍵⍳'.']}2⊃⍵}⎕NPARTS 1⊃StatusFiles),'sesslog.txt'
                  :Else
                      'Error while attempting to get log:'
                      ⎕←cJSON ⎕DMX
                  :EndTrap
                  ⎕EX'gr'
              :EndIf
              ⎕←'Killing process'
              {}proc.Kill
              ⎕EX'gr'
              ns.log←'Process did not complete within ',(1⍕0.001×⎕AI[3]-ai3),' seconds and was killed (SecondsTimeout=',(⍕specs.secondstimeout),((specs.secondstimeout=Timeout)/' default value'),')'
              (⊂ns.log)⎕NPUT 1⊃StatusFiles
              ns.R←2 ⋄ →EndJob
          :EndIf
      :EndSelect
     ⎕dl 10  ⍝ timing issue on AIX?
⍝      :If DEBUG
      ⎕←'isDTest=',(⍕isDTest)
      ⎕←'fpat=',(∊2↑⎕NPARTS 1⊃StatusFiles),'.*'
      ⎕←'ninfo=',⊃0(⎕NINFO ⎕OPT'Wildcard' 1)(∊2↑⎕NPARTS 1⊃StatusFiles),'.*'
      ⎕←'ls ',(1⊃⎕NPARTS 1⊃StatusFiles),'='
      ⎕←⎕SH'ls ',1⊃⎕NPARTS 1⊃StatusFiles
⍝      :EndIf
      ns.info←{('"',⍵,'": ',(1+⎕NEXISTS ⍵)⊃'missing' 'exists'),⎕UCS 13}¨StatusFiles
      :If ⎕NEXISTS aplcore
          ns.log←'Test led to an APLCORE: ',aplcore
          ns.R←6
          (info←_GetCoreInfo aplcore)⎕NPUT aplcore,'.txt'
          ns.info←info
          →EndJob
      :EndIf
      :If ⎕NEXISTS ns.logFile←(∊2↑⎕NPARTS 1⊃StatusFiles),'.wsfull' ⋄ ns.R←7 ⋄ →EndJob ⋄ :EndIf
      :If WSFULL ⋄ ns.R←7 ⋄ →EndJob ⋄ :EndIf
      :If ⎕NEXISTS ns.logFile←3⊃StatusFiles ⋄ ns.R←0 ⋄ →EndJob ⋄ :EndIf
      :If ⎕NEXISTS ns.logFile←2⊃StatusFiles
          ns.log←'Test created logfile "',(2⊃StatusFiles),'" to indicate failed tests. More info might be found in it and in the APL Session-log "',outfile,'"'
          ns.R←1
          →EndJob
      :EndIf
      :If ⎕NEXISTS ns.logFile←1⊃StatusFiles
          lg←1⊃⎕NGET 1⊃StatusFiles
          :If ∨/∊'TRANSLATION ERROR' '⎕UCS '⍷¨⊂lg
              ns.log←'Test created logfile "',(1⊃StatusFiles),'" to indicate APL Errors while executing tests. String-matching of that log indicates we may have hit a TRANSLATION issue (Classic vs. Unicode)'
              ns.R←8
          :Else
              ns.log←'Test created logfile "',(1⊃StatusFiles),'" to indicate APL Errors while executing tests. More info might be found in it and in the APL Session-log "',outfile,'"'
              ns.R←5
          :EndIf
        ⍝   ⎕←'log=',ns.log
          →EndJob
      :EndIf
      ⎕←'APL=','.'⎕WG'aplversion'
      ⎕←'ls ',(1⊃⎕NPARTS 1⊃StatusFiles),':'
      ⎕←⎕SH'ls ',(1⊃⎕NPARTS 1⊃StatusFiles)
      ⎕←'_RunJob returns 3. StatusFiles='
      ∊{'"',⍵,'" ',((1+⎕NEXISTS ⍵)⊃'not found! ***' 'exists'),⎕UCS 13}¨StatusFiles
      ns.R←3
      ns.logFile←∊2↑⎕NPARTS 1⊃StatusFiles  ⍝ logFile for "missing log file" will be generic (no specific extension)
     EndJob:
     EOF:
      :If DEBUG
          ⎕←'Result (ns)='
          ⎕←cJSON ns
      :EndIf
    ∇

    ∇ (rc rspec log)←_GetTestSpecs fl;cnt;specs;spec
      :Trap (~DEBUG)/rc←0
          log←''
          cnt←0
          rspec←⍬
          specs←_FoldJson 1⊃⎕NGET fl
          :If 2=specs.⎕NC'defaults'
              specs.(defaults{(⊂⍺ ⍵){(s t)←⍺ ⋄ 0=t.⎕NC ⍵:⍎'t.',⍵,'←s.',⍵}¨⍺.⎕NL-2}¨tests)    ⍝ Apply defaults to all tests
          :EndIf
          :If 0=specs.⎕NC'tests'  ⍝ optional element
              spec←⎕JSON specs
              'tests'specs.⎕NS''
              specs.tests←⎕JSON spec
          :EndIf
          ⍝ and make sure we have something in Test (will be validated later)
          :For spec :In specs.tests
            ⍝ set defaults for optional entries Setup/Teardown
              :If 0=spec.⎕NC'disabled'
              :OrIf ~(⎕C spec.disabled)∊(⊂'true')'yes' 1
                  ⍝ copy default variables from root into namespaces below tests
                  :For n :In (specs.⎕NL ¯2)~⊂'tests'
                      spec←(⊂specs n){(ns var)←⍺ ⋄ 0=⍵.⎕NC var:⍵⊣⍎'⍵.',var,'←ns.',var ⋄ ⍵}¨spec
                  :EndFor
                  spec←(⊂'setup'){0=⍵.⎕NC ⍺:⍵⊣⍵⍎⍺,'←''''' ⋄ ⍵}¨spec
                  spec←(⊂'teardown'){0=⍵.⎕NC ⍺:⍵⊣⍵⍎⍺,'←''''' ⋄ ⍵}¨spec
                  spec.secondstimeout←spec{6::⍵ ⋄ ⍺.secondstimeout}Timeout
                  cnt+←1
                  spec.id←spec{6::⍵ ⋄ ⍺⍎'id'}('nr',⍕cnt),'_',2⊃⎕NPARTS spec.test
                  rspec,←spec
              :EndIf
          :EndFor
          :If rspec≡⍬
              rc←705
              →Exit
          :EndIf
      :Else
          rc←701 ⋄ log←⊂'Error reading "',fl,'":',NL,⎕JSON ⎕DMX
      :EndTrap
    ∇



    ∇ {R}←{to}_CopyFolder from;hf;n;t;h;td
    ⍝ can't use ⎕NCOPY because that would also copy hidden files/directories - which would really hurt in the case of ".git"
    ⍝ R is returncode. Values: 0=ok
    ⍝                          1=problems copying file
    ⍝                          2=problems creating a folder
    ⍝ {to} is optional: if it is undefine, "from" sets the mode:
    ⍝ "Collect": build matrix "_CopyBuffer" as a list of from|to
    ⍝ "DoIt": copy according to buffer...
      R←0
      hf←⍬
      :If 0=⎕NC'to'
          :Select from
          :Case 'Collect'
              _CopyFolder_mode←¯1
              _CopyFolder_list←0 2⍴⊂''
              →0
          :Case 'DoIt'
              _CopyFolder_mode←1
          :Else
              ⎕←'_CopyFolder: Unknown mode "',from,'"'
              R←1 'Unknown mode "',from,'"'
              →0
          :EndSelect
      :EndIf
      from←∊1 ⎕NPARTS from ⍝ normalize it
     
      :Select _CopyFolder_mode
      :Case ¯1   ⍝ collect
          _CopyFolder_list←'_CopyFolder_list'{6::1 2⍴⍵ ⋄ (⍎⍺)⍪⍵}to from
          →R←0
      :Case 0     ⍝ normal copy
          _CopyFolder_list←1 2⍴to from
      :Case 1
          _CopyFolder_list
      :Else
          ⎕←'Unknow _CopyFolder_mode=',⍕_CopyFolder_mode
      :EndSelect
     
      :For (to from) :In ↓_CopyFolder_list
          :For (n t h) :In ↓[1]↑0 1 6(⎕NINFO ⎕OPT('Wildcard' 1)('Recurse' 1))(from,'*')   ⍝ get name, type & hidden-status
              :If ~∨/'.git'⍷n  ⍝ exclude .git*!
                  hf,←(h∧t=1)/⊂n ⍝ list of hidden directories
            ⍝   ⎕←'_CopyFolder, n,t,h= ',n,',',t,',',h
                  :If h=1 ⋄ :Continue ⋄ :EndIf
                  :If 0<≢hf ⋄ :AndIf 1∊hf{⍺≡(≢⍺)↑⍵}¨⊂n ⋄ :Continue ⋄ :EndIf ⍝ file from a hidden folder
                  :If 1=t  ⍝ directory
                      :If from≡(≢from)↑n
                          :Trap DEBUG↓0
                              3 ⎕MKDIR to,(≢from)↓n ⋄ :Continue
                          :Else
                              R←2
                              →0
                          :EndTrap
                      :Else
                          ⎕←'Paranoia justified!'
                          ∘∘∘
                      :EndIf
                  :Else
                      :If ⎕NEXISTS to,(≢from)↓n
                          ⎕←'Paranoia justified - attempted to re-copy "',from,'" to "',to,'"'
                          ⎕←'to,(≢from)↓n = ',to,(≢from)↓n
                          :Continue
                      :EndIf
                      :If ~⎕NEXISTS td←1⊃⎕NPARTS to,(≢from)↓n  ⍝ does the target dir exist?
                          3 ⎕MKDIR td
                      :EndIf
                      :If 1≠(to,(≢from)↓n)⎕NCOPY n
                          R←1
                          →0
                      :EndIf
                  :EndIf
              :EndIf
          :EndFor
      :EndFor
      R←0
    ∇

      _FoldJson←{
          0::⎕DMX.Message ⎕SIGNAL ⎕EN
          Apl←0 ⎕JSON ⎕OPT'Dialect' 'JSON5'⊢
          Json←1 ⎕JSON ⎕OPT'Compact' 0⊢
          FoldMembers←'^.*[^\\]":'⎕R{':',⍨Json ⎕C Apl ¯1↓⍵.Match}
          Apl FoldMembers Json Apl ⍵
      }

    _quote←{'"',(∊(⊂'\"')@{⍵='"'}⍵),'"'}
    _findLine←{{(+/∧\⍵=' ')↓⍵}¨l↓¨(((l←2+≢⍵)↑¨⍺)≡¨⊂'⍝',⍵,':')/⍺}

    ∇ Log←_AddLegend resTab;legend;summary
      legend←''
      summary←∊1 1↓resTab
      Log←''('Explanation of status indicator',((1<≢∪summary)/'s'),':')
      :For symb exp :In ↓ResultSymbols
          :If symb∊summary
              legend,←symb,' = ',exp,'; '
          :EndIf
      :EndFor
      Log,←⊂¯2↓legend
    ∇

    ∇ (svg lbl)←_AddTestStatusSVG res;url;s;lbl
      ⍝ get SVG from shields.io for easy status indication
      url←'https://img.shields.io/badge/status-'
      s←⍬ 0
      s[1]←+/∊res=ResultSymbols[1;1]
      s[2]←+/∊(res≠ResultSymbols[1;1])∧0<≢¨res~¨' '
      url,←(s[1]>0)/(⍕1⊃s),'%20test',((1<s[1])/'s'),'%20ok',(s[2]>0)/',%20'
      url,←(s[2]>0)/(⍕2⊃s),(((0=s[1])∧0<s[2])/'%20test',(1<s[2])/'s'),'%20failed'
      url,←'-',{∧/⍵:'orange' ⋄ ⍵[1]:'green' ⋄ 'red'}s>0
      ⍝ add the dyalog-logo:  (using a hack as seen on https://github.com/badges/shields/issues/3638#issuecomment-508241508 )
      url,←'?logo=data:image/svg%2bxml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA0MTYgNTEyIj48cGF0aCBkPSJNMCAzMnYxMTkuMmg2NFY5NmgxMDcuMkMyODQuNiA5NiAzNTIgMTc2LjIgMzUyIDI1NS45IDM1MiAzMzIgMjkzLjQgNDE2IDE3MS4yIDQxNkgwdjY0aDE3MS4yQzMzMS45IDQ4MCA0MTYgMzY3LjMgNDE2IDI1NS45YzAtNTguNy0yMi4xLTExMy40LTYyLjMtMTU0LjNDMzA4LjkgNTYgMjQ1LjcgMzIgMTcxLjIgMzJIMHoiLz48L3N2Zz4='
      res←#.HttpCommand.Get url
      :If res.rc=0
          svg←res.Data
          lbl←('aria-label=".*:\h(.*)"'⎕S'\1'⎕OPT'Greedy' 0)svg
      :ElseIf DEBUG
          ⎕←'Unexpected res!'
          ⎕←'res ⍝ examine it'
          ∘∘∘
      :Else
          svg←lbl←''
      :EndIf
    ∇

      dxb←{                                           ⍝ Drop eXtraneous Blanks.
          ⍺←' ' ⋄ 1<|≡⍵:(⊂⍺)∇¨⍵                       ⍝ nested?
          2<⍴⍴⍵:(¯1↓⍴⍵){(⍺,1↓⍴⍵)⍴⍵}⍺ ∇,[¯1↓⍳⍴⍴⍵]⍵     ⍝ array
          b←⍵∊⍺                                       ⍝ mask
          1≥⍴⍴⍵:(1↑b)↓(b⍲1↓b,1)/⍵                     ⍝ vector
          b←∧⌿b ⋄ (0,1↑b)↓(b⍲1↓b,1)/⍵                 ⍝ matrix
      }

    ∇ R←_ExpandEnvVars R;i;j;var
⍝ expands references to EnvVars in string R
⍝ need to be enclosed either in % or []
⍝ Warning: this fails utterly it you feed misconstructed strings...
      :While 0<≢i←⍸R∊'%['
          i←⊃i
          c←(1+R[⊃i]='[')⊃'%]'   ⍝ the closing character
          :If 0<j←⊃⍸(i<⍳≢R)∧R=c
              var←i↓(j-1)↑R
              var←2 ⎕NQ'.' 'GetEnvironment'var  ⍝ replace with value
              R←R[⍳i-1],var,j↓R
          :Else ⍝ closing char was not found
              'Invalid argument - not properly enclosed envvar'⎕SIGNAL 11
          :EndIf
      :EndWhile
    ∇

    ∇ _DeleteEmptyFolders path;files;folders;l;f
⍝ remove all empty folders in path
      path←∊1 ⎕NPARTS path  ⍝ normalize it
      l←↑0 1(⎕NINFO ⎕OPT('Recurse' 1)('Wildcard' 1))path,'*'  ⍝ list everything
      files←(l[2;]=2)/l[1;]
      folders←⌽(l[2;]=1)/l[1;]  ⍝ names of folders (reverse order=deepest first)
     
      :While 0<≢folders
          f←1⊃folders
          :If ~∨/∊(⊂f)⍷¨files   ⍝ if there are no files in that path
              :If ⎕NEXISTS f
                  1 ⎕NDELETE f
              :AndIf f≥⍥{+/⍵='/'}path  ⍝ if we're below path...
                  folders,←⊂1⊃⎕NPARTS f  ⍝ add parent folder to candidate list
              :EndIf
          :EndIf
          folders←1↓folders
      :End
    ∇


    ∇ file←_FileWithListOfInterpreters;docFld
      :Select platform←3↑1⊃'.'⎕WG'APLVersion'
      :Case 'Win'
          docFld←(2 ⎕NQ'.' 'GetEnvironment' 'USERPROFILE'),'/Documents/Dyalog APL Files'
      :Case 'Lin'
          docFld←'/home/',⎕AN,'/dyalog.files'
      :Case 'Mac'
          docFld←'/home/',⎕AN,'/dyalog.files'
      :EndSelect
      :If ~⎕NEXISTS docFld
          ⎕MKDIR docFld
      :EndIf
      file←∊1 ⎕NPARTS docFld,'/interpreters.json5'
    ∇

    ∇ L←_l2v L
⍝ list 2 vector
⍝ list can be "," separated or ⎕JSON-Data
⍝ (this is used to handle list of email-Addresses)
      :If ' '=⍥⎕DR L   ⍝ if it isn't a simple vector
          L←','(≠⊆⊢)L     ⍝ split it at ","
      :Else
          L←0 ⎕JSON L       ⍝ it probably is a JSON vector
      :EndIf
    ∇


⍝ this is  from the SMTP-repository:

    ∇ (rc msg server)←serverArgs _SendMail messageArgs;⎕ML;⎕IO;params;msgParams;log;server
 ⍝ Simple cover to send SMTP mail
 ⍝ Requires: SMTP class
     
 ⍝ rc   - return code; 0=no error, 1=error from the SMTP server, anything else=other error
 ⍝ msg  - descriptive message
 ⍝ server - reference to instance of SMTP (only returned when serverArgs is the server definition)
     
     
 ⍝ serverArgs is one of:
 ⍝ A server definition in one of the following formats:
 ⍝   ∘ a vector of Server Port From [Password [Userid [Secure]]]
 ⍝   ∘ a namespace containing required named elements: Server Port From
 ⍝     and optionally Password Userid Secure plus any other parameters applicable to the SMTP class
 ⍝ Or
 ⍝   ∘ an instance of the SMTP class created by SendMail
     
 ⍝ messageArgs is one of:
 ⍝ ∘ a vector of To Subj Body
 ⍝ ∘ a namespace containing required named elements: To Subj Body
 ⍝     and optionally any other parameters applicable to the SMTP.Message class
     
 ⍝ Once the SMTP server instance has been created, it is passed as the left argument
 ⍝ in subsequent calls to Sendmail
     
 ⍝ Examples:
 ⍝ (srv←⎕NS'').(Server Port From Password)←'mail.abc.com' 465 'me@abc.com' 'secret'
 ⍝ Server←3⊃srv SendMail '' ⍝ create the server instance
 ⍝ (msg←⎕NS'').(To Subj Body)←'you@xyz.com' 'Hello' 'Hi there!'
 ⍝ Server SendMail msg
 ⍝
 ⍝ The server can be created and message sent in a single call:
 ⍝ Server←3⊃srv SendMail msg
     
      ⎕IO←⎕ML←1
     
      (rc msg server)←¯1 'Nothing done' ''
      params←0
      :Select ⎕NC⊂'serverArgs'
      :Case 2.1 ⋄ params←⎕NS'' ⋄ params.(Server Port From Password Userid Secure)←''⍬'' '' '' ¯1{(≢⍺)↑⍵,⍺↓⍨≢⍵},⊆serverArgs
      :Case 9.1 ⋄ params←serverArgs
      :Case 9.2 ⋄ server←serverArgs
      :Case 0 ⍝ not defined? do nothing
      :Else ⋄ →Exit⊣(rc msg)←¯1 'Invalid serverArgs' ⍝ paranoia
      :EndSelect
     
      :If params≢0
          :Trap 0 ⋄ server←⎕NEW ##.SMTP params
          :Else ⋄ →Exit⊣(rc msg)←⎕DMX.(EN(EM,' while creating client'))
          :EndTrap
          (rc msg)←0 'SMTPClient created'
      :EndIf
     
      :If ~0∊⍴messageArgs
          :If 0∊⍴server ⋄ →Exit⊣(rc msg)←¯1 'No SMTPClient defined' ⋄ :EndIf
          :Select ⎕NC⊂'messageArgs'
          :Case 2.1 ⋄ msgParams←⎕NS'' ⋄ msgParams.(To Subj Body)←'' '' ''{(≢⍺)↑⍵,⍺↓⍨≢⍵},⊆messageArgs
          :Case 9.1 ⋄ msgParams←messageArgs
          :Else ⋄ →Exit⊣(rc msg)←¯1 'Invalid messageArgs' ⍝ paranoia
          :EndSelect
          (rc msg log)←server.Send msgParams
      :EndIf
     Exit:
    ∇

      _GetCoreInfo←{
          0=≢R←_GetInfo2 ⍵:_GetInfo ⍵ ⋄ R ⍝ if we don't find it in the ⎕MAPped files, try ⎕NREAD
      }

    ∇ r←_GetInfo wsdump;tn;interestinginfo;size;fptr;blksz;bytes;ix;ctype
⍝ this is taken from undowsdump.ws that I got from AS, saying DB wrote it.
⍝ It extracts the "interesting information" from an APLCORE passed as ⍵
⍝ this uses ⎕NREAD to read through the file....
      r←''
      interestinginfo←(⎕UCS 10),'========================== Interesting Information'
      ctype←⎕DR' '
      fptr←0
      blksz←100000
      :Trap 0
          tn←wsdump ⎕NTIE 0
      :Else
          →0
      :EndTrap
      size←⎕NSIZE tn
      :While fptr<size
          bytes←⎕NREAD tn,ctype,blksz,fptr
          ix←interestinginfo⍷bytes
          :If ∨/ix
              fptr←fptr+¯1+ix⍳1
              blksz←size-fptr
              ⎕EX'bytes'
              r←⎕NREAD tn,ctype,blksz,fptr
              ⎕NUNTIE tn
              :If ctype=80
                  r←'UTF-8'⎕UCS ⎕UCS r
              :EndIf
              r←1↓¨(r=⎕UCS 10)⊂r
              →0
          :Else
              fptr+←blksz-⍴interestinginfo               ⍝ Allow for cross-block case
          :EndIf
      :EndWhile
      ⎕NUNTIE tn
    ∇

    ∇ r←_GetInfo2 wsdump;tn;ix;ctype;interestinginfo;LF
⍝ this is taken from undowsdump.ws that I got fromAS, saying DB wrote it
⍝ it extracts the "interesting information" from an APLCORE passed as ⍵
⍝ #2 uses ⎕MAP which is preferred (but I had a test case where GetInfo2 did not find the info - and GetInfo did)
      r←''
      LF←⎕UCS 10
      interestinginfo←LF,'========================== Interesting Information'
      ctype←⎕DR' '
      :Trap 0
          r←interestinginfo{
              ix←{1≠+/⍵:⎕IO+≢⍵
                  ⍵⍳1
              }⍺⍷⍵
              ix↓⍵
          }ctype ¯1 ⎕MAP wsdump
          :If ctype=80
              r←'UTF-8'⎕UCS ⎕UCS r
          :EndIf
          r←{1↓¨(⍵=LF)⊂⍵}LF,r
      :EndTrap
    ∇

    ∇ R←{num}_getConfig name
      R←''
      :If 2=⎕SE.CITA.Config.⎕NC name
      :AndIf 0<≢⎕SE.CITA.Config⍎name
          R←⎕SE.CITA.Config⍎name
      :EndIf
      :If 0<≢r←2 ⎕NQ'.' 'GetEnvironment'('CITA_',name)
          R←r
      :EndIf
      :If 2=⎕NC'num'
      :AndIf num
          R←2⊃⎕VFI R
      :EndIf
    ∇


    ∇ R←_filenameToURL R
    ⍝ change filename of logfiles to nas00 so that we can use with <a href...
    ⍝ TODO: unfortunately still have hardcoded refs here - maybe that can be handled via CITA_Config.json5?
      ((R='\')/R)←'/'   ⍝ convert backlashes to forward slashes before inking ⎕R
      R←('U:/'⎕R'file://nas00.dyalog.bramley/devt'⍠('IC' 1))R
      R←('/devt/'⎕R'file://nas00.dyalog.bramley/devt/')R
      R←('/Volumes/'⎕R'/')R
    ∇


    :endsection



    :section UCMDs


    ∇ _InitUCMDs;fn;nr;j;parse;maxH;h;hd;r;patt;mode;H
      H←##._getHomeDir
      ct←⎕SE.Dyalog.Utils.Config'citaDEVT'
      :If '/devt/'≡6↑H   ⍝ mac3 needs "/Volumes/devt/" instead of "/devt/"
          H←('^/devt/'⎕R ct)H
      :EndIf
      ##.Home←H
      ##.UCMD._List←'[',NL
      ##.UCMD._Help←0 4⍴''   ⍝ [;1]=fn, [;2]=level, [;3]= regular hlp, [;4]=API-Help
      :For fn :In {('_'≠1⊃¨⍵)/⍵}##.API.⎕NL-3  ⍝ only for fns NOT starting with '_'
          :If (⎕NC⊂fn)≠3.1
              :Continue
          :EndIf
          nr←##.API.⎕NR fn
          j←'{'
          j,←'"Name":',_quote fn
        ⍝   j,←',"Desc":',_quote desc←∊nr _findLine':'
          j,←',"Desc":',(_quote desc←∊(nr _findLine':'),' | Version: ',1⊃_Version)
             ⍝ Parse: we also support parseU/parseA to allow for different syntax when API-Fn is used via UCMD or API-Calls.
          :If 0=≢parse←∊nr _findLine'Parse'
              parse←∊nr _findLine'UParse'
          :EndIf
     
          ⍝ must scan help here (before we may branch out of processing the cmd) to be sure that we get the help!
          :For mode :In 'UA'   ⍝ UCMD-Help and API-Help
              patt←'⍝\s*'
              :If mode='A'
                  patt←patt,'A'    ⍝ the A is mandatory for API-Help
              :Else
                  patt,←'U?'       ⍝ but the U is optional
              :EndIf
              patt,←'(\?+):'
              maxH←⌈/0,∊(patt ⎕S{¯1↑⍵.Lengths})nr
              :For h :In ⍳maxH
                  ##.UCMD._Help⍪←(⊂fn),((h-1)+0.1×mode='A'),(mode≠'A')⌽(⊂''),[1.5]{i←⍸']'=⊃¨⍵ ⋄ 1>≢i:⍵ ⋄ w←⍵ ⋄ w[i[1]]←⊂(i[1]⊃w),' | Version: ',1⊃_Version ⋄ w}nr _findLine((mode='A')/'A'),h⍴'?'    ⍝ Help for APIs has level +.1! ;)
              :EndFor
          :EndFor
          :If 0∊(≢parse),≢desc  ⍝ if either description or parsing rules are undefined, ignore this fn!
              :Continue
          :EndIf
          :If parse≡''''''   ⍝ use '' for niladic UCMDs!
              parse←''
          :EndIf
     
          j,←',"Parse":',_quote parse
          j,←',"Group":"CITA"'
          j,←'}'
          ##.UCMD._List,←j,','
     
          :Select 1 2⊃AT←##.API.⎕AT fn
          :Case 0 ⍝ niladic or not a fn
              hd←fn
          :Case 1 ⍝ monadic
              hd←fn,' rarg'
          :CaseList ¯2 2
              hd←'larg ',fn,' rarg'
          :EndSelect
          :Select 1⊃1⊃##.API.⎕AT fn
          :Case 1
              hd←'R←',hd
          :Case ¯1
              hd←'{R}←',hd
          :EndSelect
          r←'←'∊hd
          hd←(⊂hd),⊂':if 2=⎕nc''larg''⋄',(r/'R←'),'larg _getAPI ''',fn,''' rarg'
          hd,←⊂':else⋄',(r/'R←'),'_getAPI ''',fn,''' rarg'
          hd,←⊂':endif'
          :Trap 0 If DEBUG
              2 ##.⎕FIX hd
          :Else
          ⍝ return error building API fns...
              ∘∘∘
          :EndTrap
      :EndFor
      ##.UCMD.(⊃⌽_List)←']'
    ∇

    ∇ new←FilterAPLVersions arg;inst;l3;cmd;disable;z;range;objs;list;hlp;dsl;z1;z2
⍝:: Process ","-separated filters in dsl to build list of selected interpreters
⍝AParse: 1S -get∊xiovVf -ucmd=0 -list∊01234567890.,
⍝A?: This implements a DSL for selection of Dyalog interpreters:
⍝A?: [mode][[version[s]]|/][edition][bits]
⍝A?: if version(s) is elided, a / must be given to indicate missing first element. (This allows us to recognize "/32" as a bitness-selector)
⍝A?: mode is optional, default is + (select, enable). Alternative values: ~ (=un-select, disable)
⍝A?: [version] is any number, optionally with decimals and selects a version-number. Using syntax from-to you may also specify a range of versions.
⍝A?: [edition]∊uUcC or _: Unicode, Class or "_" for both
⍝A?: [bits] is 32 or 64 or can be elided to select both
⍝A?: each of the three elements can be elided, but at least one must be given for a sensible selection obviously...
⍝A?:
⍝A?: modifier -get= can be used to control the type of result:
⍝A?: x - return vtv with path(s) to exe
⍝A?: i =    -II-         id(s)
⍝A?: o =    -II-         objects (containing fields as exe, id etc. - from the file ]APLVersions uses )
⍝A?: v = return two vectors, each being a vtv itself with ids of enabled/disabled interpreters
⍝A?:     (as if applied on an empty list - but then selecting from available interpreters)
⍝A?: V= the same format & contest as "v", but the previous returns the effect of the executed DSL,
⍝A?:    whereas V reports on the current status. (to make that clear: consider 17+18 are enabled and
⍝A?:    you pass DSL +16-17.  "v" will only report 16+17 - because these were added. V reports 16,17,18
⍝A?:    because would be "current" when the DSL has been applied.) In other words:
⍝A?:    "v" starts with an empty list, "V" starts with the current list of interpreters (and then adds/removes)
⍝A?: f= return list of enabled interpreters filtered against the commands from the DSL.
⍝A?: Filters will be applied in the sequence they appear.
⍝A??: A dangerous gotcha is the fact that the DSL-Operations add or remove.
⍝A??: The expression "u" (or "+u") adds unicode-interpreters (with "V" to the current list, so it won't REMOVE classic from the list)
⍝A??: You'd need ~c to achieve that!
⍝A??: To query the list of installed v16-Interpreters, you can do "16 -v". But to get a list
⍝A??: of already enabled interpreters, you'd need more that just changing v into V, you'd also
⍝A??: have to disable unwanted interpreters: "16,~-15.99,~17- -V".
⍝A??: Switch "-list" can be used to provide a list of version numbers that will be filtered - no consideration of
⍝A??: bits or editions. (Primarily used for internal purposes)
     
      _InitUCMDs
      :If ''=⍥⎕DR arg       ⍝ if arg is char,
          arg←arg{~∨/⍵⍷⎕C ⍺:⍺,' ',⍵ ⋄ ⍺}'-ucmd=0'  ⍝ this is an API-Call - so be sure to add the -ucmd=0-modifier if we don't see it
          hlp←∨/'-?'⍷⍕arg   ⍝ remember if user asked for help
          arg←##._Parse arg
          :If hlp            ⍝ if he asked for help
              new←arg        ⍝ return it (Parse will have put it into its result!)
              →0             ⍝ and exit
          :EndIf
      :EndIf
     
      dsl←##._getArg 1 arg
      :If 0≢list←arg.Switch'list'
          list←,[1.5]','(≠⊆⊢)list
          l3←list,{⍬⍴2⊃⎕VFI ⍵}¨list
      :Else
          objs←⎕JSON 1⊃⎕NGET _FileWithListOfInterpreters
          objs←(objs.id≢¨⊂'doc')/objs
          list←objs.id
          l3←('(\d\d[\.?\d]?)([ |c|u])(\d{2})'⎕S'\1 \2 \3'⎕OPT 1)list
      ⍝ convert list into [;1]=id, [;2]=version, [;3]=bits, [;4]=edition
          l3←list,↑{({⍬⍴(2⊃⎕VFI 2↑⍵)+(2<≢⍵)×0.1×2⊃⎕VFI ¯1↑⍵}¨⍵[1 3]),⎕C 2⊃⍵}¨{' '(≠⊆⊢)⍵}¨l3
      :EndIf
      :If 'V'=arg.Switch'get'
          new←({6::1 ⋄ 0=≢⍵.disabled}¨objs)/objs.id   ⍝ start with current list and then apply changes if we're in V-mode!
      :Else
          new←⍬   ⍝ start with an empty list
      :EndIf
      :If 0≢dsl
          :For cmd :In ','(≠⊆⊢),dsl   ⍝ look at one instruction after the next
              disable←'~'=⊃cmd ⋄ cmd←(∨/'+~'=⊃cmd)↓cmd
              :If cmd≡⍥⎕C'all'
                  z←(≢l3)⍴1
              :Else
                  :If '/'≠⊃cmd
                      range←0 ¯1 99 0 0 ⍝ range[1]: yes, "-" was used, [2] is start and [3] is end of range, range [4 5]: was a '.' used in the version-spec 2&3
                      :If ∧/(2↑cmd)∊⎕D
                          z←∧\cmd∊⎕D  ⍝ just get the leading digits
                          range[2]←⍬⍴2⊃⎕VFI z/cmd
                          cmd←(~z)/cmd
                          :If 0<≢cmd
                          :AndIf range[4]←∨/z←∧\cmd∊'.',⎕D
                              range[2]+←{⍵<1:⍵ ⋄ ⍵×0.1}⍬⍴2⊃⎕VFI(('.'≠⊃cmd)⍴'.'),z/cmd
                              cmd←(~z)/cmd
                          :EndIf
                      :EndIf
                      range[1]←'-'=⊃cmd
                      :If '+'=⊃cmd ⍝ "+" after first version indicates "open range" (ending with 99)
                          cmd←1↓cmd
                          range[1]←1
                      :EndIf
                      cmd←range[1]↓cmd
                      :If 0<≢cmd
                      :AndIf ∨/z←∧\((≢cmd)↑1 1)∧cmd∊⎕D,'.'  ⍝ just get the leading digits
                          range[3]←⍬⍴(2⊃⎕VFI z/cmd)+⍬⍴0.1×{2⊃⎕VFI'.'~⍨(∧\⍵∊⎕D,'.')/⍵}'0',⍨(~z)/cmd
                          cmd←(~z)/cmd
                          :If 0<≢cmd
                          :AndIf range[5]←∨/z←∧\cmd∊'.',⎕D
                              range[3]+←{⍵<1:⍵ ⋄ ⍵×0.1}2⊃⎕VFI z/cmd
                              cmd←(~z)/cmd
                          :EndIf
                      :EndIf
                      range[2]←{⍵[2]:⍵[1] ⋄ ⌊⍵[1]}range[2 4]
                      range[3]←{⍵[2]:⍵[1] ⋄ 0.999+⌊⍵[1]}range[3 5]
                      :If range[1]  ⍝ if range was specified
                          z←l3[;2]{(⍵[1]≤⍺)∧(⍵[2]≥⍺)∨⍵[2]=¯1}1↓range
                      :ElseIf range[4] ⍝ if . was used in 2
                          z←(l3[;2])=range[2]  ⍝ version must match exactly
                      :ElseIf range[2]>0
                          z←(⌊l3[;2])=range[2]
                      :Else
                          ⎕EX'z'
                      :EndIf
                  :Else
                      cmd←1↓cmd
                  :EndIf
                  :If 2<¯1↑⍴l3   ⍝ if we know bits/edition (NOT working against -list, but using "real" specs)
                      :If ∨/'_uc'∊⎕C⊃cmd
                          :If (⎕C⊃cmd)∊'cu'
                              z←'z'{6::⍵ ⋄ ⍵∧⍎⍺}l3[;4]=⎕C⊃cmd
                          :Else
                              z←'z'{6::⍵ ⋄ ⍵∧⍎⍺}(≢l3)⍴1  ⍝ select all
                          :EndIf
                          cmd←1↓cmd
                      :EndIf
                      :If (⊂cmd)∊'32' '64'
                          z←'z'{6::⍵ ⋄ ⍵∧⍎⍺}l3[;3]∊2⊃⎕VFI cmd
                      :EndIf
                  :EndIf
              :EndIf
              :If 0=⎕NC'z'
                  :Continue
              :EndIf ⍝ nothing has been selected
              :If disable
                  new←new~z/l3[;1]
              :Else
                  new∪←z/l3[;1]
              :EndIf
          :EndFor
      :ElseIf 'f'=arg.Switch'get'
          new←objs.id
      :EndIf
      :If 0≢cmd←arg.Switch'get'
          z←objs.id∊new
          :Select ''⍴cmd
          :Case 'x'
              new←z/objs.exe
          :Case 'i'
              new←z/objs.id
          :Case 'o'
              new←z/objs
          :Case 'v'
              new←(z/objs.id)((~z)/objs.id)
          :Case 'V'
              z1←objs.id≢⊂'doc'
              z2←{6::1 ⋄ 0=≢⍵.disabled}¨objs
              ⍝new←((z1∧z2)/objs.id)((z1∧~z2)/objs.id)
              new←(new)(objs.id~new)
          :CaseList 'fF'
              z←(objs.id∊new)∧{6::1 ⋄ 0=≢⍵.disabled}¨objs
              new←z/objs.id
          :EndSelect
      :EndIf
     
    ∇
    :endsection
:endnamespace
